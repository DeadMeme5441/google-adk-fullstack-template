/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * FastAPI
 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import { customInstance } from "./mutator";
export type APIKeyDescription = string | null;

export interface APIKey {
  type?: SecuritySchemeType;
  description?: APIKeyDescription;
  in: APIKeyIn;
  name: string;
  [key: string]: unknown;
}

export type APIKeyIn = (typeof APIKeyIn)[keyof typeof APIKeyIn];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const APIKeyIn = {
  query: "query",
  header: "header",
  cookie: "cookie",
} as const;

export interface AddSessionToEvalSetRequest {
  evalId: string;
  sessionId: string;
  userId: string;
}

/**
 * The API secret.
 */
export type ApiAuthApiKeyConfigProperty = ApiAuthApiKeyConfig | null;

/**
 * The generic reusable api auth config.

Deprecated. Please use AuthConfig (google/cloud/aiplatform/master/auth.proto)
instead.
 */
export interface ApiAuth {
  /** The API secret. */
  apiKeyConfig?: ApiAuthApiKeyConfigProperty;
}

/**
 * Required. The SecretManager secret version resource name storing API key. e.g. projects/{project}/secrets/{secret}/versions/{version}
 */
export type ApiAuthApiKeyConfigApiKeySecretVersion = string | null;

/**
 * The API key string. Either this or `api_key_secret_version` must be set.
 */
export type ApiAuthApiKeyConfigApiKeyString = string | null;

/**
 * The API secret.
 */
export interface ApiAuthApiKeyConfig {
  /** Required. The SecretManager secret version resource name storing API key. e.g. projects/{project}/secrets/{secret}/versions/{version} */
  apiKeySecretVersion?: ApiAuthApiKeyConfigApiKeySecretVersion;
  /** The API key string. Either this or `api_key_secret_version` must be set. */
  apiKeyString?: ApiAuthApiKeyConfigApiKeyString;
}

/**
 * The API key to be used in the request directly.
 */
export type ApiKeyConfigApiKeyString = string | null;

/**
 * Config for authentication with API key.
 */
export interface ApiKeyConfig {
  /** The API key to be used in the request directly. */
  apiKeyString?: ApiKeyConfigApiKeyString;
}

/**
 * The API spec that the external API implements.
 */
export type ApiSpec = (typeof ApiSpec)[keyof typeof ApiSpec];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApiSpec = {
  API_SPEC_UNSPECIFIED: "API_SPEC_UNSPECIFIED",
  SIMPLE_SEARCH: "SIMPLE_SEARCH",
  ELASTIC_SEARCH: "ELASTIC_SEARCH",
} as const;

/**
 * Optional. The service account that the extension execution service runs as. - If the service account is specified, the `iam.serviceAccounts.getAccessToken` permission should be granted to Vertex AI Extension Service Agent (https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents) on the specified service account. - If not specified, the Vertex AI Extension Service Agent will be used to execute the Extension.
 */
export type AuthConfigGoogleServiceAccountConfigServiceAccount = string | null;

/**
 * Config for Google Service Account Authentication.
 */
export interface AuthConfigGoogleServiceAccountConfig {
  /** Optional. The service account that the extension execution service runs as. - If the service account is specified, the `iam.serviceAccounts.getAccessToken` permission should be granted to Vertex AI Extension Service Agent (https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents) on the specified service account. - If not specified, the Vertex AI Extension Service Agent will be used to execute the Extension. */
  serviceAccount?: AuthConfigGoogleServiceAccountConfigServiceAccount;
}

/**
 * Required. The name of the SecretManager secret version resource storing the base64 encoded credentials. Format: `projects/{project}/secrets/{secrete}/versions/{version}` - If specified, the `secretmanager.versions.access` permission should be granted to Vertex AI Extension Service Agent (https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents) on the specified resource.
 */
export type AuthConfigHttpBasicAuthConfigCredentialSecret = string | null;

/**
 * Config for HTTP Basic Authentication.
 */
export interface AuthConfigHttpBasicAuthConfig {
  /** Required. The name of the SecretManager secret version resource storing the base64 encoded credentials. Format: `projects/{project}/secrets/{secrete}/versions/{version}` - If specified, the `secretmanager.versions.access` permission should be granted to Vertex AI Extension Service Agent (https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents) on the specified resource. */
  credentialSecret?: AuthConfigHttpBasicAuthConfigCredentialSecret;
}

/**
 * Access token for extension endpoint. Only used to propagate token from [[ExecuteExtensionRequest.runtime_auth_config]] at request time.
 */
export type AuthConfigOauthConfigAccessToken = string | null;

/**
 * The service account used to generate access tokens for executing the Extension. - If the service account is specified, the `iam.serviceAccounts.getAccessToken` permission should be granted to Vertex AI Extension Service Agent (https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents) on the provided service account.
 */
export type AuthConfigOauthConfigServiceAccount = string | null;

/**
 * Config for user oauth.
 */
export interface AuthConfigOauthConfig {
  /** Access token for extension endpoint. Only used to propagate token from [[ExecuteExtensionRequest.runtime_auth_config]] at request time. */
  accessToken?: AuthConfigOauthConfigAccessToken;
  /** The service account used to generate access tokens for executing the Extension. - If the service account is specified, the `iam.serviceAccounts.getAccessToken` permission should be granted to Vertex AI Extension Service Agent (https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents) on the provided service account. */
  serviceAccount?: AuthConfigOauthConfigServiceAccount;
}

/**
 * OpenID Connect formatted ID token for extension endpoint. Only used to propagate token from [[ExecuteExtensionRequest.runtime_auth_config]] at request time.
 */
export type AuthConfigOidcConfigIdToken = string | null;

/**
 * The service account used to generate an OpenID Connect (OIDC)-compatible JWT token signed by the Google OIDC Provider (accounts.google.com) for extension endpoint (https://cloud.google.com/iam/docs/create-short-lived-credentials-direct#sa-credentials-oidc). - The audience for the token will be set to the URL in the server url defined in the OpenApi spec. - If the service account is provided, the service account should grant `iam.serviceAccounts.getOpenIdToken` permission to Vertex AI Extension Service Agent (https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents).
 */
export type AuthConfigOidcConfigServiceAccount = string | null;

/**
 * Config for user OIDC auth.
 */
export interface AuthConfigOidcConfig {
  /** OpenID Connect formatted ID token for extension endpoint. Only used to propagate token from [[ExecuteExtensionRequest.runtime_auth_config]] at request time. */
  idToken?: AuthConfigOidcConfigIdToken;
  /** The service account used to generate an OpenID Connect (OIDC)-compatible JWT token signed by the Google OIDC Provider (accounts.google.com) for extension endpoint (https://cloud.google.com/iam/docs/create-short-lived-credentials-direct#sa-credentials-oidc). - The audience for the token will be set to the URL in the server url defined in the OpenApi spec. - If the service account is provided, the service account should grant `iam.serviceAccounts.getOpenIdToken` permission to Vertex AI Extension Service Agent (https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents). */
  serviceAccount?: AuthConfigOidcConfigServiceAccount;
}

export type AuthCredentialInputResourceRef = string | null;

export type AuthCredentialInputApiKey = string | null;

export type AuthCredentialInputHttp = HttpAuth | null;

export type AuthCredentialInputServiceAccount = ServiceAccount | null;

export type AuthCredentialInputOauth2 = OAuth2Auth | null;

/**
 * Data class representing an authentication credential.

To exchange for the actual credential, please use
CredentialExchanger.exchange_credential().

Examples: API Key Auth
AuthCredential(
    auth_type=AuthCredentialTypes.API_KEY,
    api_key="1234",
)

Example: HTTP Auth
AuthCredential(
    auth_type=AuthCredentialTypes.HTTP,
    http=HttpAuth(
        scheme="basic",
        credentials=HttpCredentials(username="user", password="password"),
    ),
)

Example: OAuth2 Bearer Token in HTTP Header
AuthCredential(
    auth_type=AuthCredentialTypes.HTTP,
    http=HttpAuth(
        scheme="bearer",
        credentials=HttpCredentials(token="eyAkaknabna...."),
    ),
)

Example: OAuth2 Auth with Authorization Code Flow
AuthCredential(
    auth_type=AuthCredentialTypes.OAUTH2,
    oauth2=OAuth2Auth(
        client_id="1234",
        client_secret="secret",
    ),
)

Example: OpenID Connect Auth
AuthCredential(
    auth_type=AuthCredentialTypes.OPEN_ID_CONNECT,
    oauth2=OAuth2Auth(
        client_id="1234",
        client_secret="secret",
        redirect_uri="https://example.com",
        scopes=["scope1", "scope2"],
    ),
)

Example: Auth with resource reference
AuthCredential(
    auth_type=AuthCredentialTypes.API_KEY,
    resource_ref="projects/1234/locations/us-central1/resources/resource1",
)
 */
export interface AuthCredentialInput {
  authType: AuthCredentialTypes;
  resourceRef?: AuthCredentialInputResourceRef;
  apiKey?: AuthCredentialInputApiKey;
  http?: AuthCredentialInputHttp;
  serviceAccount?: AuthCredentialInputServiceAccount;
  oauth2?: AuthCredentialInputOauth2;
  [key: string]: unknown;
}

export type AuthCredentialOutputResourceRef = string | null;

export type AuthCredentialOutputApiKey = string | null;

export type AuthCredentialOutputHttp = HttpAuth | null;

export type AuthCredentialOutputServiceAccount = ServiceAccount | null;

export type AuthCredentialOutputOauth2 = OAuth2Auth | null;

/**
 * Data class representing an authentication credential.

To exchange for the actual credential, please use
CredentialExchanger.exchange_credential().

Examples: API Key Auth
AuthCredential(
    auth_type=AuthCredentialTypes.API_KEY,
    api_key="1234",
)

Example: HTTP Auth
AuthCredential(
    auth_type=AuthCredentialTypes.HTTP,
    http=HttpAuth(
        scheme="basic",
        credentials=HttpCredentials(username="user", password="password"),
    ),
)

Example: OAuth2 Bearer Token in HTTP Header
AuthCredential(
    auth_type=AuthCredentialTypes.HTTP,
    http=HttpAuth(
        scheme="bearer",
        credentials=HttpCredentials(token="eyAkaknabna...."),
    ),
)

Example: OAuth2 Auth with Authorization Code Flow
AuthCredential(
    auth_type=AuthCredentialTypes.OAUTH2,
    oauth2=OAuth2Auth(
        client_id="1234",
        client_secret="secret",
    ),
)

Example: OpenID Connect Auth
AuthCredential(
    auth_type=AuthCredentialTypes.OPEN_ID_CONNECT,
    oauth2=OAuth2Auth(
        client_id="1234",
        client_secret="secret",
        redirect_uri="https://example.com",
        scopes=["scope1", "scope2"],
    ),
)

Example: Auth with resource reference
AuthCredential(
    auth_type=AuthCredentialTypes.API_KEY,
    resource_ref="projects/1234/locations/us-central1/resources/resource1",
)
 */
export interface AuthCredentialOutput {
  authType: AuthCredentialTypes;
  resourceRef?: AuthCredentialOutputResourceRef;
  apiKey?: AuthCredentialOutputApiKey;
  http?: AuthCredentialOutputHttp;
  serviceAccount?: AuthCredentialOutputServiceAccount;
  oauth2?: AuthCredentialOutputOauth2;
  [key: string]: unknown;
}

/**
 * Represents the type of authentication credential.
 */
export type AuthCredentialTypes =
  (typeof AuthCredentialTypes)[keyof typeof AuthCredentialTypes];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthCredentialTypes = {
  apiKey: "apiKey",
  http: "http",
  oauth2: "oauth2",
  openIdConnect: "openIdConnect",
  serviceAccount: "serviceAccount",
} as const;

/**
 * Type of auth scheme.
 */
export type AuthType = (typeof AuthType)[keyof typeof AuthType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthType = {
  AUTH_TYPE_UNSPECIFIED: "AUTH_TYPE_UNSPECIFIED",
  NO_AUTH: "NO_AUTH",
  API_KEY_AUTH: "API_KEY_AUTH",
  HTTP_BASIC_AUTH: "HTTP_BASIC_AUTH",
  GOOGLE_SERVICE_ACCOUNT_AUTH: "GOOGLE_SERVICE_ACCOUNT_AUTH",
  OAUTH: "OAUTH",
  OIDC_AUTH: "OIDC_AUTH",
} as const;

/**
 * Whether to disable automatic function calling.
      If not set or set to False, will enable automatic function calling.
      If set to True, will disable automatic function calling.
      
 */
export type AutomaticFunctionCallingConfigDisable = boolean | null;

/**
 * If automatic function calling is enabled,
      maximum number of remote calls for automatic function calling.
      This number should be a positive integer.
      If not set, SDK will set maximum number of remote calls to 10.
      
 */
export type AutomaticFunctionCallingConfigMaximumRemoteCalls = number | null;

/**
 * If automatic function calling is enabled,
      whether to ignore call history to the response.
      If not set, SDK will set ignore_call_history to false,
      and will append the call history to
      GenerateContentResponse.automatic_function_calling_history.
      
 */
export type AutomaticFunctionCallingConfigIgnoreCallHistory = boolean | null;

/**
 * The configuration for automatic function calling.
 */
export interface AutomaticFunctionCallingConfig {
  /** Whether to disable automatic function calling.
      If not set or set to False, will enable automatic function calling.
      If set to True, will disable automatic function calling.
       */
  disable?: AutomaticFunctionCallingConfigDisable;
  /** If automatic function calling is enabled,
      maximum number of remote calls for automatic function calling.
      This number should be a positive integer.
      If not set, SDK will set maximum number of remote calls to 10.
       */
  maximumRemoteCalls?: AutomaticFunctionCallingConfigMaximumRemoteCalls;
  /** If automatic function calling is enabled,
      whether to ignore call history to the response.
      If not set, SDK will set ignore_call_history to false,
      and will append the call history to
      GenerateContentResponse.automatic_function_calling_history.
       */
  ignoreCallHistory?: AutomaticFunctionCallingConfigIgnoreCallHistory;
}

/**
 * Defines the function behavior. Defaults to `BLOCKING`.
 */
export type Behavior = (typeof Behavior)[keyof typeof Behavior];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Behavior = {
  UNSPECIFIED: "UNSPECIFIED",
  BLOCKING: "BLOCKING",
  NON_BLOCKING: "NON_BLOCKING",
} as const;

/**
 * Optional. Display name of the blob. Used to provide a label or filename to distinguish blobs. This field is not currently used in the Gemini GenerateContent calls.
 */
export type BlobDisplayName = string | null;

/**
 * Required. Raw bytes.
 */
export type BlobData = string | null;

/**
 * Required. The IANA standard MIME type of the source data.
 */
export type BlobMimeType = string | null;

/**
 * Content blob.
 */
export interface Blob {
  /** Optional. Display name of the blob. Used to provide a label or filename to distinguish blobs. This field is not currently used in the Gemini GenerateContent calls. */
  displayName?: BlobDisplayName;
  /** Required. Raw bytes. */
  data?: BlobData;
  /** Required. The IANA standard MIME type of the source data. */
  mimeType?: BlobMimeType;
}

export type BodyCreateSessionAppsAppNameUsersUserIdSessionsPostStateAnyOf = {
  [key: string]: unknown;
};

export type BodyCreateSessionAppsAppNameUsersUserIdSessionsPostState =
  BodyCreateSessionAppsAppNameUsersUserIdSessionsPostStateAnyOf | null;

export type BodyCreateSessionAppsAppNameUsersUserIdSessionsPostEvents =
  | EventInput[]
  | null;

export interface BodyCreateSessionAppsAppNameUsersUserIdSessionsPost {
  state?: BodyCreateSessionAppsAppNameUsersUserIdSessionsPostState;
  events?: BodyCreateSessionAppsAppNameUsersUserIdSessionsPostEvents;
}

/**
 * Required. Outcome of the code execution.
 */
export type CodeExecutionResultOutcome = Outcome | null;

/**
 * Optional. Contains stdout when code execution is successful, stderr or other description otherwise.
 */
export type CodeExecutionResultOutput = string | null;

/**
 * Result of executing the [ExecutableCode].

Only generated when using the [CodeExecution] tool, and always follows a
`part` containing the [ExecutableCode].
 */
export interface CodeExecutionResult {
  /** Required. Outcome of the code execution. */
  outcome?: CodeExecutionResultOutcome;
  /** Optional. Contains stdout when code execution is successful, stderr or other description otherwise. */
  output?: CodeExecutionResultOutput;
}

/**
 * List of parts that constitute a single message. Each part may have
      a different IANA MIME type.
 */
export type ContentInputParts = PartInput[] | null;

/**
 * Optional. The producer of the content. Must be either 'user' or
      'model'. Useful to set for multi-turn conversations, otherwise can be
      empty. If role is not specified, SDK will determine the role.
 */
export type ContentInputRole = string | null;

/**
 * Contains the multi-part content of a message.
 */
export interface ContentInput {
  /** List of parts that constitute a single message. Each part may have
      a different IANA MIME type. */
  parts?: ContentInputParts;
  /** Optional. The producer of the content. Must be either 'user' or
      'model'. Useful to set for multi-turn conversations, otherwise can be
      empty. If role is not specified, SDK will determine the role. */
  role?: ContentInputRole;
}

/**
 * List of parts that constitute a single message. Each part may have
      a different IANA MIME type.
 */
export type ContentOutputParts = PartOutput[] | null;

/**
 * Optional. The producer of the content. Must be either 'user' or
      'model'. Useful to set for multi-turn conversations, otherwise can be
      empty. If role is not specified, SDK will determine the role.
 */
export type ContentOutputRole = string | null;

/**
 * Contains the multi-part content of a message.
 */
export interface ContentOutput {
  /** List of parts that constitute a single message. Each part may have
      a different IANA MIME type. */
  parts?: ContentOutputParts;
  /** Optional. The producer of the content. Must be either 'user' or
      'model'. Useful to set for multi-turn conversations, otherwise can be
      empty. If role is not specified, SDK will determine the role. */
  role?: ContentOutputRole;
}

export interface CreateEvalSetRequest {
  evalSet: EvalSetInput;
}

/**
 * The mode of the predictor to be used in dynamic retrieval.
 */
export type DynamicRetrievalConfigModeProperty =
  DynamicRetrievalConfigMode | null;

/**
 * Optional. The threshold to be used in dynamic retrieval. If not set, a system default value is used.
 */
export type DynamicRetrievalConfigDynamicThreshold = number | null;

/**
 * Describes the options to customize dynamic retrieval.
 */
export interface DynamicRetrievalConfig {
  /** The mode of the predictor to be used in dynamic retrieval. */
  mode?: DynamicRetrievalConfigModeProperty;
  /** Optional. The threshold to be used in dynamic retrieval. If not set, a system default value is used. */
  dynamicThreshold?: DynamicRetrievalConfigDynamicThreshold;
}

/**
 * Config for the dynamic retrieval config mode.
 */
export type DynamicRetrievalConfigMode =
  (typeof DynamicRetrievalConfigMode)[keyof typeof DynamicRetrievalConfigMode];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DynamicRetrievalConfigMode = {
  MODE_UNSPECIFIED: "MODE_UNSPECIFIED",
  MODE_DYNAMIC: "MODE_DYNAMIC",
} as const;

/**
 * Optional. List of domains to be excluded from the search results. The default limit is 2000 domains.
 */
export type EnterpriseWebSearchExcludeDomains = string[] | null;

/**
 * Tool to search public web data, powered by Vertex AI Search and Sec4 compliance.
 */
export interface EnterpriseWebSearch {
  /** Optional. List of domains to be excluded from the search results. The default limit is 2000 domains. */
  excludeDomains?: EnterpriseWebSearchExcludeDomains;
}

/**
 * The environment being operated.
 */
export type Environment = (typeof Environment)[keyof typeof Environment];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Environment = {
  ENVIRONMENT_UNSPECIFIED: "ENVIRONMENT_UNSPECIFIED",
  ENVIRONMENT_BROWSER: "ENVIRONMENT_BROWSER",
} as const;

export type EvalCaseInputSessionInput = SessionInput | null;

/**
 * An eval case.
 */
export interface EvalCaseInput {
  evalId: string;
  conversation: InvocationInput[];
  sessionInput?: EvalCaseInputSessionInput;
  creationTimestamp?: number;
}

export type EvalCaseOutputSessionInput = SessionInput | null;

/**
 * An eval case.
 */
export interface EvalCaseOutput {
  evalId: string;
  conversation: InvocationOutput[];
  sessionInput?: EvalCaseOutputSessionInput;
  creationTimestamp?: number;
}

/**
 * This field is deprecated, use eval_set_id instead.
 * @deprecated
 */
export type EvalCaseResultEvalSetFile = string | null;

/**
 * This field is deprecated, use overall_eval_metric_results instead.
 * @deprecated
 */
export type EvalCaseResultEvalMetricResults =
  | [EvalMetricOutput, EvalMetricResult][]
  | null;

export type EvalCaseResultSessionDetails = Session | null;

export type EvalCaseResultUserId = string | null;

/**
 * Case level evaluation results.
 */
export interface EvalCaseResult {
  /**
   * This field is deprecated, use eval_set_id instead.
   * @deprecated
   */
  evalSetFile?: EvalCaseResultEvalSetFile;
  evalSetId?: string;
  evalId?: string;
  finalEvalStatus: EvalStatus;
  /**
   * This field is deprecated, use overall_eval_metric_results instead.
   * @deprecated
   */
  evalMetricResults?: EvalCaseResultEvalMetricResults;
  overallEvalMetricResults: EvalMetricResult[];
  evalMetricResultPerInvocation: EvalMetricResultPerInvocation[];
  sessionId: string;
  sessionDetails?: EvalCaseResultSessionDetails;
  userId?: EvalCaseResultUserId;
}

/**
 * Options for the judge model.
 */
export type EvalMetricInputJudgeModelOptions = JudgeModelOptionsInput | null;

/**
 * A metric used to evaluate a particular aspect of an eval case.
 */
export interface EvalMetricInput {
  /** The name of the metric. */
  metricName: string;
  /** A threshold value. Each metric decides how to interpret this threshold. */
  threshold: number;
  /** Options for the judge model. */
  judgeModelOptions?: EvalMetricInputJudgeModelOptions;
}

/**
 * Options for the judge model.
 */
export type EvalMetricOutputJudgeModelOptions = JudgeModelOptionsOutput | null;

/**
 * A metric used to evaluate a particular aspect of an eval case.
 */
export interface EvalMetricOutput {
  /** The name of the metric. */
  metricName: string;
  /** A threshold value. Each metric decides how to interpret this threshold. */
  threshold: number;
  /** Options for the judge model. */
  judgeModelOptions?: EvalMetricOutputJudgeModelOptions;
}

/**
 * Options for the judge model.
 */
export type EvalMetricResultJudgeModelOptions = JudgeModelOptionsOutput | null;

/**
 * Score obtained after evaluating the metric. Optional, as evaluation might not have happened.
 */
export type EvalMetricResultScore = number | null;

/**
 * The actual computed score/value of a particular EvalMetric.
 */
export interface EvalMetricResult {
  /** The name of the metric. */
  metricName: string;
  /** A threshold value. Each metric decides how to interpret this threshold. */
  threshold: number;
  /** Options for the judge model. */
  judgeModelOptions?: EvalMetricResultJudgeModelOptions;
  /** Score obtained after evaluating the metric. Optional, as evaluation might not have happened. */
  score?: EvalMetricResultScore;
  /** The status of this evaluation. */
  evalStatus: EvalStatus;
}

/**
 * Eval metric results per invocation.
 */
export interface EvalMetricResultPerInvocation {
  /** The actual invocation, usually obtained by inferencing the agent. */
  actualInvocation: InvocationOutput;
  /** The expected invocation, usually the reference or golden invocation. */
  expectedInvocation: InvocationOutput;
  /** Eval resutls for each applicable metric. */
  evalMetricResults?: EvalMetricResult[];
}

export type EvalResultEvalSetResultName = string | null;

/**
 * This class has no field intentionally.

The goal here is to just give a new name to the class to align with the API
endpoint.
 */
export interface EvalResult {
  evalSetResultId: string;
  evalSetResultName?: EvalResultEvalSetResultName;
  evalSetId: string;
  evalCaseResults?: EvalCaseResult[];
  creationTimestamp?: number;
}

export type EvalSetInputName = string | null;

export type EvalSetInputDescription = string | null;

/**
 * A set of eval cases.
 */
export interface EvalSetInput {
  eval_set_id: string;
  name?: EvalSetInputName;
  description?: EvalSetInputDescription;
  eval_cases: EvalCaseInput[];
  creation_timestamp?: number;
}

export type EvalSetOutputName = string | null;

export type EvalSetOutputDescription = string | null;

/**
 * A set of eval cases.
 */
export interface EvalSetOutput {
  eval_set_id: string;
  name?: EvalSetOutputName;
  description?: EvalSetOutputDescription;
  eval_cases: EvalCaseOutput[];
  creation_timestamp?: number;
}

export type EvalSetResultEvalSetResultName = string | null;

/**
 * Eval set level evaluation results.
 */
export interface EvalSetResult {
  evalSetResultId: string;
  evalSetResultName?: EvalSetResultEvalSetResultName;
  evalSetId: string;
  evalCaseResults?: EvalCaseResult[];
  creationTimestamp?: number;
}

export type EvalStatus = (typeof EvalStatus)[keyof typeof EvalStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EvalStatus = {
  NUMBER_1: 1,
  NUMBER_2: 2,
  NUMBER_3: 3,
} as const;

export type EventInputContent = ContentInput | null;

export type EventInputGroundingMetadata = GroundingMetadataInput | null;

export type EventInputPartial = boolean | null;

export type EventInputTurnComplete = boolean | null;

export type EventInputFinishReason = FinishReason | null;

export type EventInputErrorCode = string | null;

export type EventInputErrorMessage = string | null;

export type EventInputInterrupted = boolean | null;

export type EventInputCustomMetadataAnyOf = { [key: string]: unknown };

export type EventInputCustomMetadata = EventInputCustomMetadataAnyOf | null;

export type EventInputUsageMetadata =
  GenerateContentResponseUsageMetadataInput | null;

export type EventInputLiveSessionResumptionUpdate =
  LiveServerSessionResumptionUpdate | null;

export type EventInputInputTranscription = Transcription | null;

export type EventInputOutputTranscription = Transcription | null;

export type EventInputLongRunningToolIds = string[] | null;

export type EventInputBranch = string | null;

/**
 * Represents an event in a conversation between agents and users.

It is used to store the content of the conversation, as well as the actions
taken by the agents like function calls, etc.

Attributes:
  invocation_id: Required. The invocation ID of the event. Should be non-empty
    before appending to a session.
  author: Required. "user" or the name of the agent, indicating who appended
    the event to the session.
  actions: The actions taken by the agent.
  long_running_tool_ids: The ids of the long running function calls.
  branch: The branch of the event.
  id: The unique identifier of the event.
  timestamp: The timestamp of the event.
  get_function_calls: Returns the function calls in the event.
 */
export interface EventInput {
  content?: EventInputContent;
  groundingMetadata?: EventInputGroundingMetadata;
  partial?: EventInputPartial;
  turnComplete?: EventInputTurnComplete;
  finishReason?: EventInputFinishReason;
  errorCode?: EventInputErrorCode;
  errorMessage?: EventInputErrorMessage;
  interrupted?: EventInputInterrupted;
  customMetadata?: EventInputCustomMetadata;
  usageMetadata?: EventInputUsageMetadata;
  liveSessionResumptionUpdate?: EventInputLiveSessionResumptionUpdate;
  inputTranscription?: EventInputInputTranscription;
  outputTranscription?: EventInputOutputTranscription;
  invocationId?: string;
  author: string;
  actions?: EventActionsInput;
  longRunningToolIds?: EventInputLongRunningToolIds;
  branch?: EventInputBranch;
  id?: string;
  timestamp?: number;
}

export type EventOutputContent = ContentOutput | null;

export type EventOutputGroundingMetadata = GroundingMetadataOutput | null;

export type EventOutputPartial = boolean | null;

export type EventOutputTurnComplete = boolean | null;

export type EventOutputFinishReason = FinishReason | null;

export type EventOutputErrorCode = string | null;

export type EventOutputErrorMessage = string | null;

export type EventOutputInterrupted = boolean | null;

export type EventOutputCustomMetadataAnyOf = { [key: string]: unknown };

export type EventOutputCustomMetadata = EventOutputCustomMetadataAnyOf | null;

export type EventOutputUsageMetadata =
  GenerateContentResponseUsageMetadataOutput | null;

export type EventOutputLiveSessionResumptionUpdate =
  LiveServerSessionResumptionUpdate | null;

export type EventOutputInputTranscription = Transcription | null;

export type EventOutputOutputTranscription = Transcription | null;

export type EventOutputLongRunningToolIds = string[] | null;

export type EventOutputBranch = string | null;

/**
 * Represents an event in a conversation between agents and users.

It is used to store the content of the conversation, as well as the actions
taken by the agents like function calls, etc.

Attributes:
  invocation_id: Required. The invocation ID of the event. Should be non-empty
    before appending to a session.
  author: Required. "user" or the name of the agent, indicating who appended
    the event to the session.
  actions: The actions taken by the agent.
  long_running_tool_ids: The ids of the long running function calls.
  branch: The branch of the event.
  id: The unique identifier of the event.
  timestamp: The timestamp of the event.
  get_function_calls: Returns the function calls in the event.
 */
export interface EventOutput {
  content?: EventOutputContent;
  groundingMetadata?: EventOutputGroundingMetadata;
  partial?: EventOutputPartial;
  turnComplete?: EventOutputTurnComplete;
  finishReason?: EventOutputFinishReason;
  errorCode?: EventOutputErrorCode;
  errorMessage?: EventOutputErrorMessage;
  interrupted?: EventOutputInterrupted;
  customMetadata?: EventOutputCustomMetadata;
  usageMetadata?: EventOutputUsageMetadata;
  liveSessionResumptionUpdate?: EventOutputLiveSessionResumptionUpdate;
  inputTranscription?: EventOutputInputTranscription;
  outputTranscription?: EventOutputOutputTranscription;
  invocationId?: string;
  author: string;
  actions?: EventActionsOutput;
  longRunningToolIds?: EventOutputLongRunningToolIds;
  branch?: EventOutputBranch;
  id?: string;
  timestamp?: number;
}

export type EventActionsInputSkipSummarization = boolean | null;

export type EventActionsInputStateDelta = { [key: string]: unknown };

export type EventActionsInputArtifactDelta = { [key: string]: number };

export type EventActionsInputTransferToAgent = string | null;

export type EventActionsInputEscalate = boolean | null;

export type EventActionsInputRequestedAuthConfigs = {
  [key: string]: GoogleAdkAuthAuthToolAuthConfigInput;
};

/**
 * Represents the actions attached to an event.
 */
export interface EventActionsInput {
  skipSummarization?: EventActionsInputSkipSummarization;
  stateDelta?: EventActionsInputStateDelta;
  artifactDelta?: EventActionsInputArtifactDelta;
  transferToAgent?: EventActionsInputTransferToAgent;
  escalate?: EventActionsInputEscalate;
  requestedAuthConfigs?: EventActionsInputRequestedAuthConfigs;
}

export type EventActionsOutputSkipSummarization = boolean | null;

export type EventActionsOutputStateDelta = { [key: string]: unknown };

export type EventActionsOutputArtifactDelta = { [key: string]: number };

export type EventActionsOutputTransferToAgent = string | null;

export type EventActionsOutputEscalate = boolean | null;

export type EventActionsOutputRequestedAuthConfigs = {
  [key: string]: GoogleAdkAuthAuthToolAuthConfigOutput;
};

/**
 * Represents the actions attached to an event.
 */
export interface EventActionsOutput {
  skipSummarization?: EventActionsOutputSkipSummarization;
  stateDelta?: EventActionsOutputStateDelta;
  artifactDelta?: EventActionsOutputArtifactDelta;
  transferToAgent?: EventActionsOutputTransferToAgent;
  escalate?: EventActionsOutputEscalate;
  requestedAuthConfigs?: EventActionsOutputRequestedAuthConfigs;
}

/**
 * Required. The code to be executed.
 */
export type ExecutableCodeCode = string | null;

/**
 * Required. Programming language of the `code`.
 */
export type ExecutableCodeLanguage = Language | null;

/**
 * Code generated by the model that is meant to be executed, and the result returned to the model.

Generated when using the [CodeExecution] tool, in which the code will be
automatically executed, and a corresponding [CodeExecutionResult] will also be
generated.
 */
export interface ExecutableCode {
  /** Required. The code to be executed. */
  code?: ExecutableCodeCode;
  /** Required. Programming language of the `code`. */
  language?: ExecutableCodeLanguage;
}

/**
 * The authentication config to access the API. Deprecated. Please use auth_config instead.
 */
export type ExternalApiInputApiAuth = ApiAuth | null;

/**
 * The API spec that the external API implements.
 */
export type ExternalApiInputApiSpec = ApiSpec | null;

/**
 * The authentication config to access the API.
 */
export type ExternalApiInputAuthConfig = GoogleGenaiTypesAuthConfig | null;

/**
 * Parameters for the elastic search API.
 */
export type ExternalApiInputElasticSearchParams =
  ExternalApiElasticSearchParams | null;

/**
 * The endpoint of the external API. The system will call the API at this endpoint to retrieve the data for grounding. Example: https://acme.com:443/search
 */
export type ExternalApiInputEndpoint = string | null;

/**
 * Parameters for the simple search API.
 */
export type ExternalApiInputSimpleSearchParams =
  ExternalApiSimpleSearchParams | null;

/**
 * Retrieve from data source powered by external API for grounding.

The external API is not owned by Google, but need to follow the pre-defined
API spec.
 */
export interface ExternalApiInput {
  /** The authentication config to access the API. Deprecated. Please use auth_config instead. */
  apiAuth?: ExternalApiInputApiAuth;
  /** The API spec that the external API implements. */
  apiSpec?: ExternalApiInputApiSpec;
  /** The authentication config to access the API. */
  authConfig?: ExternalApiInputAuthConfig;
  /** Parameters for the elastic search API. */
  elasticSearchParams?: ExternalApiInputElasticSearchParams;
  /** The endpoint of the external API. The system will call the API at this endpoint to retrieve the data for grounding. Example: https://acme.com:443/search */
  endpoint?: ExternalApiInputEndpoint;
  /** Parameters for the simple search API. */
  simpleSearchParams?: ExternalApiInputSimpleSearchParams;
}

/**
 * The authentication config to access the API. Deprecated. Please use auth_config instead.
 */
export type ExternalApiOutputApiAuth = ApiAuth | null;

/**
 * The API spec that the external API implements.
 */
export type ExternalApiOutputApiSpec = ApiSpec | null;

/**
 * The authentication config to access the API.
 */
export type ExternalApiOutputAuthConfig = GoogleGenaiTypesAuthConfig | null;

/**
 * Parameters for the elastic search API.
 */
export type ExternalApiOutputElasticSearchParams =
  ExternalApiElasticSearchParams | null;

/**
 * The endpoint of the external API. The system will call the API at this endpoint to retrieve the data for grounding. Example: https://acme.com:443/search
 */
export type ExternalApiOutputEndpoint = string | null;

/**
 * Parameters for the simple search API.
 */
export type ExternalApiOutputSimpleSearchParams =
  ExternalApiSimpleSearchParams | null;

/**
 * Retrieve from data source powered by external API for grounding.

The external API is not owned by Google, but need to follow the pre-defined
API spec.
 */
export interface ExternalApiOutput {
  /** The authentication config to access the API. Deprecated. Please use auth_config instead. */
  apiAuth?: ExternalApiOutputApiAuth;
  /** The API spec that the external API implements. */
  apiSpec?: ExternalApiOutputApiSpec;
  /** The authentication config to access the API. */
  authConfig?: ExternalApiOutputAuthConfig;
  /** Parameters for the elastic search API. */
  elasticSearchParams?: ExternalApiOutputElasticSearchParams;
  /** The endpoint of the external API. The system will call the API at this endpoint to retrieve the data for grounding. Example: https://acme.com:443/search */
  endpoint?: ExternalApiOutputEndpoint;
  /** Parameters for the simple search API. */
  simpleSearchParams?: ExternalApiOutputSimpleSearchParams;
}

/**
 * The ElasticSearch index to use.
 */
export type ExternalApiElasticSearchParamsIndex = string | null;

/**
 * Optional. Number of hits (chunks) to request. When specified, it is passed to Elasticsearch as the `num_hits` param.
 */
export type ExternalApiElasticSearchParamsNumHits = number | null;

/**
 * The ElasticSearch search template to use.
 */
export type ExternalApiElasticSearchParamsSearchTemplate = string | null;

/**
 * The search parameters to use for the ELASTIC_SEARCH spec.
 */
export interface ExternalApiElasticSearchParams {
  /** The ElasticSearch index to use. */
  index?: ExternalApiElasticSearchParamsIndex;
  /** Optional. Number of hits (chunks) to request. When specified, it is passed to Elasticsearch as the `num_hits` param. */
  numHits?: ExternalApiElasticSearchParamsNumHits;
  /** The ElasticSearch search template to use. */
  searchTemplate?: ExternalApiElasticSearchParamsSearchTemplate;
}

/**
 * The search parameters to use for SIMPLE_SEARCH spec.
 */
export interface ExternalApiSimpleSearchParams {
  [key: string]: unknown;
}

/**
 * Options for feature selection preference.
 */
export type FeatureSelectionPreference =
  (typeof FeatureSelectionPreference)[keyof typeof FeatureSelectionPreference];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FeatureSelectionPreference = {
  FEATURE_SELECTION_PREFERENCE_UNSPECIFIED:
    "FEATURE_SELECTION_PREFERENCE_UNSPECIFIED",
  PRIORITIZE_QUALITY: "PRIORITIZE_QUALITY",
  BALANCED: "BALANCED",
  PRIORITIZE_COST: "PRIORITIZE_COST",
} as const;

/**
 * The `File` resource name. The ID (name excluding the "files/" prefix) can contain up to 40 characters that are lowercase alphanumeric or dashes (-). The ID cannot start or end with a dash. If the name is empty on create, a unique name will be generated. Example: `files/123-456`
 */
export type FileName = string | null;

/**
 * Optional. The human-readable display name for the `File`. The display name must be no more than 512 characters in length, including spaces. Example: 'Welcome Image'
 */
export type FileDisplayName = string | null;

/**
 * Output only. MIME type of the file.
 */
export type FileMimeType = string | null;

/**
 * Output only. Size of the file in bytes.
 */
export type FileSizeBytes = number | null;

/**
 * Output only. The timestamp of when the `File` was created.
 */
export type FileCreateTime = string | null;

/**
 * Output only. The timestamp of when the `File` will be deleted. Only set if the `File` is scheduled to expire.
 */
export type FileExpirationTime = string | null;

/**
 * Output only. The timestamp of when the `File` was last updated.
 */
export type FileUpdateTime = string | null;

/**
 * Output only. SHA-256 hash of the uploaded bytes. The hash value is encoded in base64 format.
 */
export type FileSha256Hash = string | null;

/**
 * Output only. The URI of the `File`.
 */
export type FileUri = string | null;

/**
 * Output only. The URI of the `File`, only set for downloadable (generated) files.
 */
export type FileDownloadUri = string | null;

/**
 * Output only. Processing state of the File.
 */
export type FileStateProperty = FileState | null;

/**
 * Output only. The source of the `File`.
 */
export type FileSourceProperty = FileSource | null;

export type FileVideoMetadataAnyOf = { [key: string]: unknown };

/**
 * Output only. Metadata for a video.
 */
export type FileVideoMetadata = FileVideoMetadataAnyOf | null;

/**
 * Output only. Error status if File processing failed.
 */
export type FileError = FileStatus | null;

/**
 * A file uploaded to the API.
 */
export interface File {
  /** The `File` resource name. The ID (name excluding the "files/" prefix) can contain up to 40 characters that are lowercase alphanumeric or dashes (-). The ID cannot start or end with a dash. If the name is empty on create, a unique name will be generated. Example: `files/123-456` */
  name?: FileName;
  /** Optional. The human-readable display name for the `File`. The display name must be no more than 512 characters in length, including spaces. Example: 'Welcome Image' */
  displayName?: FileDisplayName;
  /** Output only. MIME type of the file. */
  mimeType?: FileMimeType;
  /** Output only. Size of the file in bytes. */
  sizeBytes?: FileSizeBytes;
  /** Output only. The timestamp of when the `File` was created. */
  createTime?: FileCreateTime;
  /** Output only. The timestamp of when the `File` will be deleted. Only set if the `File` is scheduled to expire. */
  expirationTime?: FileExpirationTime;
  /** Output only. The timestamp of when the `File` was last updated. */
  updateTime?: FileUpdateTime;
  /** Output only. SHA-256 hash of the uploaded bytes. The hash value is encoded in base64 format. */
  sha256Hash?: FileSha256Hash;
  /** Output only. The URI of the `File`. */
  uri?: FileUri;
  /** Output only. The URI of the `File`, only set for downloadable (generated) files. */
  downloadUri?: FileDownloadUri;
  /** Output only. Processing state of the File. */
  state?: FileStateProperty;
  /** Output only. The source of the `File`. */
  source?: FileSourceProperty;
  /** Output only. Metadata for a video. */
  videoMetadata?: FileVideoMetadata;
  /** Output only. Error status if File processing failed. */
  error?: FileError;
}

/**
 * Optional. Display name of the file data. Used to provide a label or filename to distinguish file datas. It is not currently used in the Gemini GenerateContent calls.
 */
export type FileDataDisplayName = string | null;

/**
 * Required. URI.
 */
export type FileDataFileUri = string | null;

/**
 * Required. The IANA standard MIME type of the source data.
 */
export type FileDataMimeType = string | null;

/**
 * URI based data.
 */
export interface FileData {
  /** Optional. Display name of the file data. Used to provide a label or filename to distinguish file datas. It is not currently used in the Gemini GenerateContent calls. */
  displayName?: FileDataDisplayName;
  /** Required. URI. */
  fileUri?: FileDataFileUri;
  /** Required. The IANA standard MIME type of the source data. */
  mimeType?: FileDataMimeType;
}

/**
 * Source of the File.
 */
export type FileSource = (typeof FileSource)[keyof typeof FileSource];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FileSource = {
  SOURCE_UNSPECIFIED: "SOURCE_UNSPECIFIED",
  UPLOADED: "UPLOADED",
  GENERATED: "GENERATED",
} as const;

/**
 * State for the lifecycle of a File.
 */
export type FileState = (typeof FileState)[keyof typeof FileState];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FileState = {
  STATE_UNSPECIFIED: "STATE_UNSPECIFIED",
  PROCESSING: "PROCESSING",
  ACTIVE: "ACTIVE",
  FAILED: "FAILED",
} as const;

export type FileStatusDetailsAnyOfItem = { [key: string]: unknown };

/**
 * A list of messages that carry the error details. There is a common set of message types for APIs to use.
 */
export type FileStatusDetails = FileStatusDetailsAnyOfItem[] | null;

/**
 * A list of messages that carry the error details. There is a common set of message types for APIs to use.
 */
export type FileStatusMessage = string | null;

/**
 * The status code. 0 for OK, 1 for CANCELLED
 */
export type FileStatusCode = number | null;

/**
 * Status of a File that uses a common error model.
 */
export interface FileStatus {
  /** A list of messages that carry the error details. There is a common set of message types for APIs to use. */
  details?: FileStatusDetails;
  /** A list of messages that carry the error details. There is a common set of message types for APIs to use. */
  message?: FileStatusMessage;
  /** The status code. 0 for OK, 1 for CANCELLED */
  code?: FileStatusCode;
}

/**
 * Output only. The reason why the model stopped generating tokens.

If empty, the model has not stopped generating the tokens.
 */
export type FinishReason = (typeof FinishReason)[keyof typeof FinishReason];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FinishReason = {
  FINISH_REASON_UNSPECIFIED: "FINISH_REASON_UNSPECIFIED",
  STOP: "STOP",
  MAX_TOKENS: "MAX_TOKENS",
  SAFETY: "SAFETY",
  RECITATION: "RECITATION",
  LANGUAGE: "LANGUAGE",
  OTHER: "OTHER",
  BLOCKLIST: "BLOCKLIST",
  PROHIBITED_CONTENT: "PROHIBITED_CONTENT",
  SPII: "SPII",
  MALFORMED_FUNCTION_CALL: "MALFORMED_FUNCTION_CALL",
  IMAGE_SAFETY: "IMAGE_SAFETY",
  UNEXPECTED_TOOL_CALL: "UNEXPECTED_TOOL_CALL",
} as const;

/**
 * The unique id of the function call. If populated, the client to execute the
   `function_call` and return the response with the matching `id`.
 */
export type FunctionCallId = string | null;

export type FunctionCallArgsAnyOf = { [key: string]: unknown };

/**
 * Optional. The function parameters and values in JSON object format. See [FunctionDeclaration.parameters] for parameter details.
 */
export type FunctionCallArgs = FunctionCallArgsAnyOf | null;

/**
 * Required. The name of the function to call. Matches [FunctionDeclaration.name].
 */
export type FunctionCallName = string | null;

/**
 * A function call.
 */
export interface FunctionCall {
  /** The unique id of the function call. If populated, the client to execute the
   `function_call` and return the response with the matching `id`. */
  id?: FunctionCallId;
  /** Optional. The function parameters and values in JSON object format. See [FunctionDeclaration.parameters] for parameter details. */
  args?: FunctionCallArgs;
  /** Required. The name of the function to call. Matches [FunctionDeclaration.name]. */
  name?: FunctionCallName;
}

/**
 * Optional. Function calling mode.
 */
export type FunctionCallingConfigModeProperty =
  FunctionCallingConfigMode | null;

/**
 * Optional. Function names to call. Only set when the Mode is ANY. Function names should match [FunctionDeclaration.name]. With mode set to ANY, model will predict a function call from the set of function names provided.
 */
export type FunctionCallingConfigAllowedFunctionNames = string[] | null;

/**
 * Function calling config.
 */
export interface FunctionCallingConfig {
  /** Optional. Function calling mode. */
  mode?: FunctionCallingConfigModeProperty;
  /** Optional. Function names to call. Only set when the Mode is ANY. Function names should match [FunctionDeclaration.name]. With mode set to ANY, model will predict a function call from the set of function names provided. */
  allowedFunctionNames?: FunctionCallingConfigAllowedFunctionNames;
}

/**
 * Config for the function calling config mode.
 */
export type FunctionCallingConfigMode =
  (typeof FunctionCallingConfigMode)[keyof typeof FunctionCallingConfigMode];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FunctionCallingConfigMode = {
  MODE_UNSPECIFIED: "MODE_UNSPECIFIED",
  AUTO: "AUTO",
  ANY: "ANY",
  NONE: "NONE",
  VALIDATED: "VALIDATED",
} as const;

/**
 * Defines the function behavior.
 */
export type FunctionDeclarationInputBehavior = Behavior | null;

/**
 * Optional. Description and purpose of the function. Model uses it to decide how and whether to call the function.
 */
export type FunctionDeclarationInputDescription = string | null;

/**
 * Required. The name of the function to call. Must start with a letter or an underscore. Must be a-z, A-Z, 0-9, or contain underscores, dots and dashes, with a maximum length of 64.
 */
export type FunctionDeclarationInputName = string | null;

/**
 * Optional. Describes the parameters to this function in JSON Schema Object format. Reflects the Open API 3.03 Parameter Object. string Key: the name of the parameter. Parameter names are case sensitive. Schema Value: the Schema defining the type used for the parameter. For function with no parameters, this can be left unset. Parameter names must start with a letter or an underscore and must only contain chars a-z, A-Z, 0-9, or underscores with a maximum length of 64. Example with 1 required and 1 optional parameter: type: OBJECT properties: param1: type: STRING param2: type: INTEGER required: - param1
 */
export type FunctionDeclarationInputParameters = SchemaInput | null;

/**
 * Optional. Describes the parameters to the function in JSON Schema format. The schema must describe an object where the properties are the parameters to the function. For example: ``` { "type": "object", "properties": { "name": { "type": "string" }, "age": { "type": "integer" } }, "additionalProperties": false, "required": ["name", "age"], "propertyOrdering": ["name", "age"] } ``` This field is mutually exclusive with `parameters`.
 */
export type FunctionDeclarationInputParametersJsonSchema = unknown | null;

/**
 * Optional. Describes the output from this function in JSON Schema format. Reflects the Open API 3.03 Response Object. The Schema defines the type used for the response value of the function.
 */
export type FunctionDeclarationInputResponse = SchemaInput | null;

/**
 * Optional. Describes the output from this function in JSON Schema format. The value specified by the schema is the response value of the function. This field is mutually exclusive with `response`.
 */
export type FunctionDeclarationInputResponseJsonSchema = unknown | null;

/**
 * Defines a function that the model can generate JSON inputs for.

The inputs are based on `OpenAPI 3.0 specifications
<https://spec.openapis.org/oas/v3.0.3>`_.
 */
export interface FunctionDeclarationInput {
  /** Defines the function behavior. */
  behavior?: FunctionDeclarationInputBehavior;
  /** Optional. Description and purpose of the function. Model uses it to decide how and whether to call the function. */
  description?: FunctionDeclarationInputDescription;
  /** Required. The name of the function to call. Must start with a letter or an underscore. Must be a-z, A-Z, 0-9, or contain underscores, dots and dashes, with a maximum length of 64. */
  name?: FunctionDeclarationInputName;
  /** Optional. Describes the parameters to this function in JSON Schema Object format. Reflects the Open API 3.03 Parameter Object. string Key: the name of the parameter. Parameter names are case sensitive. Schema Value: the Schema defining the type used for the parameter. For function with no parameters, this can be left unset. Parameter names must start with a letter or an underscore and must only contain chars a-z, A-Z, 0-9, or underscores with a maximum length of 64. Example with 1 required and 1 optional parameter: type: OBJECT properties: param1: type: STRING param2: type: INTEGER required: - param1 */
  parameters?: FunctionDeclarationInputParameters;
  /** Optional. Describes the parameters to the function in JSON Schema format. The schema must describe an object where the properties are the parameters to the function. For example: ``` { "type": "object", "properties": { "name": { "type": "string" }, "age": { "type": "integer" } }, "additionalProperties": false, "required": ["name", "age"], "propertyOrdering": ["name", "age"] } ``` This field is mutually exclusive with `parameters`. */
  parametersJsonSchema?: FunctionDeclarationInputParametersJsonSchema;
  /** Optional. Describes the output from this function in JSON Schema format. Reflects the Open API 3.03 Response Object. The Schema defines the type used for the response value of the function. */
  response?: FunctionDeclarationInputResponse;
  /** Optional. Describes the output from this function in JSON Schema format. The value specified by the schema is the response value of the function. This field is mutually exclusive with `response`. */
  responseJsonSchema?: FunctionDeclarationInputResponseJsonSchema;
}

/**
 * Defines the function behavior.
 */
export type FunctionDeclarationOutputBehavior = Behavior | null;

/**
 * Optional. Description and purpose of the function. Model uses it to decide how and whether to call the function.
 */
export type FunctionDeclarationOutputDescription = string | null;

/**
 * Required. The name of the function to call. Must start with a letter or an underscore. Must be a-z, A-Z, 0-9, or contain underscores, dots and dashes, with a maximum length of 64.
 */
export type FunctionDeclarationOutputName = string | null;

/**
 * Optional. Describes the parameters to this function in JSON Schema Object format. Reflects the Open API 3.03 Parameter Object. string Key: the name of the parameter. Parameter names are case sensitive. Schema Value: the Schema defining the type used for the parameter. For function with no parameters, this can be left unset. Parameter names must start with a letter or an underscore and must only contain chars a-z, A-Z, 0-9, or underscores with a maximum length of 64. Example with 1 required and 1 optional parameter: type: OBJECT properties: param1: type: STRING param2: type: INTEGER required: - param1
 */
export type FunctionDeclarationOutputParameters = SchemaOutput | null;

/**
 * Optional. Describes the parameters to the function in JSON Schema format. The schema must describe an object where the properties are the parameters to the function. For example: ``` { "type": "object", "properties": { "name": { "type": "string" }, "age": { "type": "integer" } }, "additionalProperties": false, "required": ["name", "age"], "propertyOrdering": ["name", "age"] } ``` This field is mutually exclusive with `parameters`.
 */
export type FunctionDeclarationOutputParametersJsonSchema = unknown | null;

/**
 * Optional. Describes the output from this function in JSON Schema format. Reflects the Open API 3.03 Response Object. The Schema defines the type used for the response value of the function.
 */
export type FunctionDeclarationOutputResponse = SchemaOutput | null;

/**
 * Optional. Describes the output from this function in JSON Schema format. The value specified by the schema is the response value of the function. This field is mutually exclusive with `response`.
 */
export type FunctionDeclarationOutputResponseJsonSchema = unknown | null;

/**
 * Defines a function that the model can generate JSON inputs for.

The inputs are based on `OpenAPI 3.0 specifications
<https://spec.openapis.org/oas/v3.0.3>`_.
 */
export interface FunctionDeclarationOutput {
  /** Defines the function behavior. */
  behavior?: FunctionDeclarationOutputBehavior;
  /** Optional. Description and purpose of the function. Model uses it to decide how and whether to call the function. */
  description?: FunctionDeclarationOutputDescription;
  /** Required. The name of the function to call. Must start with a letter or an underscore. Must be a-z, A-Z, 0-9, or contain underscores, dots and dashes, with a maximum length of 64. */
  name?: FunctionDeclarationOutputName;
  /** Optional. Describes the parameters to this function in JSON Schema Object format. Reflects the Open API 3.03 Parameter Object. string Key: the name of the parameter. Parameter names are case sensitive. Schema Value: the Schema defining the type used for the parameter. For function with no parameters, this can be left unset. Parameter names must start with a letter or an underscore and must only contain chars a-z, A-Z, 0-9, or underscores with a maximum length of 64. Example with 1 required and 1 optional parameter: type: OBJECT properties: param1: type: STRING param2: type: INTEGER required: - param1 */
  parameters?: FunctionDeclarationOutputParameters;
  /** Optional. Describes the parameters to the function in JSON Schema format. The schema must describe an object where the properties are the parameters to the function. For example: ``` { "type": "object", "properties": { "name": { "type": "string" }, "age": { "type": "integer" } }, "additionalProperties": false, "required": ["name", "age"], "propertyOrdering": ["name", "age"] } ``` This field is mutually exclusive with `parameters`. */
  parametersJsonSchema?: FunctionDeclarationOutputParametersJsonSchema;
  /** Optional. Describes the output from this function in JSON Schema format. Reflects the Open API 3.03 Response Object. The Schema defines the type used for the response value of the function. */
  response?: FunctionDeclarationOutputResponse;
  /** Optional. Describes the output from this function in JSON Schema format. The value specified by the schema is the response value of the function. This field is mutually exclusive with `response`. */
  responseJsonSchema?: FunctionDeclarationOutputResponseJsonSchema;
}

/**
 * Signals that function call continues, and more responses will be returned, turning the function call into a generator. Is only applicable to NON_BLOCKING function calls (see FunctionDeclaration.behavior for details), ignored otherwise. If false, the default, future responses will not be considered. Is only applicable to NON_BLOCKING function calls, is ignored otherwise. If set to false, future responses will not be considered. It is allowed to return empty `response` with `will_continue=False` to signal that the function call is finished.
 */
export type FunctionResponseWillContinue = boolean | null;

/**
 * Specifies how the response should be scheduled in the conversation. Only applicable to NON_BLOCKING function calls, is ignored otherwise. Defaults to WHEN_IDLE.
 */
export type FunctionResponseSchedulingProperty =
  FunctionResponseScheduling | null;

/**
 * Optional. The id of the function call this response is for. Populated by the client to match the corresponding function call `id`.
 */
export type FunctionResponseId = string | null;

/**
 * Required. The name of the function to call. Matches [FunctionDeclaration.name] and [FunctionCall.name].
 */
export type FunctionResponseName = string | null;

export type FunctionResponseResponseAnyOf = { [key: string]: unknown };

/**
 * Required. The function response in JSON object format. Use "output" key to specify function output and "error" key to specify error details (if any). If "output" and "error" keys are not specified, then whole "response" is treated as function output.
 */
export type FunctionResponseResponse = FunctionResponseResponseAnyOf | null;

/**
 * A function response.
 */
export interface FunctionResponse {
  /** Signals that function call continues, and more responses will be returned, turning the function call into a generator. Is only applicable to NON_BLOCKING function calls (see FunctionDeclaration.behavior for details), ignored otherwise. If false, the default, future responses will not be considered. Is only applicable to NON_BLOCKING function calls, is ignored otherwise. If set to false, future responses will not be considered. It is allowed to return empty `response` with `will_continue=False` to signal that the function call is finished. */
  willContinue?: FunctionResponseWillContinue;
  /** Specifies how the response should be scheduled in the conversation. Only applicable to NON_BLOCKING function calls, is ignored otherwise. Defaults to WHEN_IDLE. */
  scheduling?: FunctionResponseSchedulingProperty;
  /** Optional. The id of the function call this response is for. Populated by the client to match the corresponding function call `id`. */
  id?: FunctionResponseId;
  /** Required. The name of the function to call. Matches [FunctionDeclaration.name] and [FunctionCall.name]. */
  name?: FunctionResponseName;
  /** Required. The function response in JSON object format. Use "output" key to specify function output and "error" key to specify error details (if any). If "output" and "error" keys are not specified, then whole "response" is treated as function output. */
  response?: FunctionResponseResponse;
}

/**
 * Specifies how the response should be scheduled in the conversation.
 */
export type FunctionResponseScheduling =
  (typeof FunctionResponseScheduling)[keyof typeof FunctionResponseScheduling];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FunctionResponseScheduling = {
  SCHEDULING_UNSPECIFIED: "SCHEDULING_UNSPECIFIED",
  SILENT: "SILENT",
  WHEN_IDLE: "WHEN_IDLE",
  INTERRUPT: "INTERRUPT",
} as const;

/**
 * Used to override HTTP request options.
 */
export type GenerateContentConfigInputHttpOptions = HttpOptions | null;

export type GenerateContentConfigInputSystemInstructionAnyOfItem =
  | string
  | File
  | PartInput;

/**
 * Instructions for the model to steer it toward better performance.
      For example, "Answer as concisely as possible" or "Don't use technical
      terms in your response".
      
 */
export type GenerateContentConfigInputSystemInstruction =
  | ContentInput
  | string
  | File
  | PartInput
  | GenerateContentConfigInputSystemInstructionAnyOfItem[]
  | null;

/**
 * Value that controls the degree of randomness in token selection.
      Lower temperatures are good for prompts that require a less open-ended or
      creative response, while higher temperatures can lead to more diverse or
      creative results.
      
 */
export type GenerateContentConfigInputTemperature = number | null;

/**
 * Tokens are selected from the most to least probable until the sum
      of their probabilities equals this value. Use a lower value for less
      random responses and a higher value for more random responses.
      
 */
export type GenerateContentConfigInputTopP = number | null;

/**
 * For each token selection step, the ``top_k`` tokens with the
      highest probabilities are sampled. Then tokens are further filtered based
      on ``top_p`` with the final token selected using temperature sampling. Use
      a lower number for less random responses and a higher number for more
      random responses.
      
 */
export type GenerateContentConfigInputTopK = number | null;

/**
 * Number of response variations to return.
      
 */
export type GenerateContentConfigInputCandidateCount = number | null;

/**
 * Maximum number of tokens that can be generated in the response.
      
 */
export type GenerateContentConfigInputMaxOutputTokens = number | null;

/**
 * List of strings that tells the model to stop generating text if one
      of the strings is encountered in the response.
      
 */
export type GenerateContentConfigInputStopSequences = string[] | null;

/**
 * Whether to return the log probabilities of the tokens that were
      chosen by the model at each step.
      
 */
export type GenerateContentConfigInputResponseLogprobs = boolean | null;

/**
 * Number of top candidate tokens to return the log probabilities for
      at each generation step.
      
 */
export type GenerateContentConfigInputLogprobs = number | null;

/**
 * Positive values penalize tokens that already appear in the
      generated text, increasing the probability of generating more diverse
      content.
      
 */
export type GenerateContentConfigInputPresencePenalty = number | null;

/**
 * Positive values penalize tokens that repeatedly appear in the
      generated text, increasing the probability of generating more diverse
      content.
      
 */
export type GenerateContentConfigInputFrequencyPenalty = number | null;

/**
 * When ``seed`` is fixed to a specific number, the model makes a best
      effort to provide the same response for repeated requests. By default, a
      random number is used.
      
 */
export type GenerateContentConfigInputSeed = number | null;

/**
 * Output response mimetype of the generated candidate text.
      Supported mimetype:
        - `text/plain`: (default) Text output.
        - `application/json`: JSON response in the candidates.
      The model needs to be prompted to output the appropriate response type,
      otherwise the behavior is undefined.
      This is a preview feature.
      
 */
export type GenerateContentConfigInputResponseMimeType = string | null;

export type GenerateContentConfigInputResponseSchemaAnyOf = {
  [key: string]: unknown;
};

/**
 * The `Schema` object allows the definition of input and output data types.
      These types can be objects, but also primitives and arrays.
      Represents a select subset of an [OpenAPI 3.0 schema
      object](https://spec.openapis.org/oas/v3.0.3#schema).
      If set, a compatible response_mime_type must also be set.
      Compatible mimetypes: `application/json`: Schema for JSON response.
      
 */
export type GenerateContentConfigInputResponseSchema =
  | GenerateContentConfigInputResponseSchemaAnyOf
  | SchemaInput
  | null;

/**
 * Optional. Output schema of the generated response.
      This is an alternative to `response_schema` that accepts [JSON
      Schema](https://json-schema.org/). If set, `response_schema` must be
      omitted, but `response_mime_type` is required. While the full JSON Schema
      may be sent, not all features are supported. Specifically, only the
      following properties are supported: - `$id` - `$defs` - `$ref` - `$anchor`
      - `type` - `format` - `title` - `description` - `enum` (for strings and
      numbers) - `items` - `prefixItems` - `minItems` - `maxItems` - `minimum` -
      `maximum` - `anyOf` - `oneOf` (interpreted the same as `anyOf`) -
      `properties` - `additionalProperties` - `required` The non-standard
      `propertyOrdering` property may also be set. Cyclic references are
      unrolled to a limited degree and, as such, may only be used within
      non-required properties. (Nullable properties are not sufficient.) If
      `$ref` is set on a sub-schema, no other properties, except for than those
      starting as a `$`, may be set.
 */
export type GenerateContentConfigInputResponseJsonSchema = unknown | null;

/**
 * Configuration for model router requests.
      
 */
export type GenerateContentConfigInputRoutingConfig =
  GenerationConfigRoutingConfig | null;

/**
 * Configuration for model selection.
      
 */
export type GenerateContentConfigInputModelSelectionConfig =
  ModelSelectionConfig | null;

/**
 * Safety settings in the request to block unsafe content in the
      response.
      
 */
export type GenerateContentConfigInputSafetySettings = SafetySetting[] | null;

export type GenerateContentConfigInputToolsAnyOfItem =
  | GoogleGenaiTypesToolInput
  | McpTypesTool;

/**
 * Code that enables the system to interact with external systems to
      perform an action outside of the knowledge and scope of the model.
      
 */
export type GenerateContentConfigInputTools =
  | GenerateContentConfigInputToolsAnyOfItem[]
  | null;

/**
 * Associates model output to a specific function call.
      
 */
export type GenerateContentConfigInputToolConfig = ToolConfigInput | null;

export type GenerateContentConfigInputLabelsAnyOf = { [key: string]: string };

/**
 * Labels with user-defined metadata to break down billed charges.
 */
export type GenerateContentConfigInputLabels =
  GenerateContentConfigInputLabelsAnyOf | null;

/**
 * Resource name of a context cache that can be used in subsequent
      requests.
      
 */
export type GenerateContentConfigInputCachedContent = string | null;

/**
 * The requested modalities of the response. Represents the set of
      modalities that the model can return.
      
 */
export type GenerateContentConfigInputResponseModalities = string[] | null;

/**
 * If specified, the media resolution specified will be used.
    
 */
export type GenerateContentConfigInputMediaResolution = MediaResolution | null;

/**
 * The speech generation configuration.
      
 */
export type GenerateContentConfigInputSpeechConfig =
  | string
  | SpeechConfigInput
  | null;

/**
 * If enabled, audio timestamp will be included in the request to the
       model.
      
 */
export type GenerateContentConfigInputAudioTimestamp = boolean | null;

/**
 * The configuration for automatic function calling.
      
 */
export type GenerateContentConfigInputAutomaticFunctionCalling =
  AutomaticFunctionCallingConfig | null;

/**
 * The thinking features configuration.
      
 */
export type GenerateContentConfigInputThinkingConfig = ThinkingConfig | null;

/**
 * Optional model configuration parameters.

For more information, see `Content generation parameters
<https://cloud.google.com/vertex-ai/generative-ai/docs/multimodal/content-generation-parameters>`_.
 */
export interface GenerateContentConfigInput {
  /** Used to override HTTP request options. */
  httpOptions?: GenerateContentConfigInputHttpOptions;
  /** Instructions for the model to steer it toward better performance.
      For example, "Answer as concisely as possible" or "Don't use technical
      terms in your response".
       */
  systemInstruction?: GenerateContentConfigInputSystemInstruction;
  /** Value that controls the degree of randomness in token selection.
      Lower temperatures are good for prompts that require a less open-ended or
      creative response, while higher temperatures can lead to more diverse or
      creative results.
       */
  temperature?: GenerateContentConfigInputTemperature;
  /** Tokens are selected from the most to least probable until the sum
      of their probabilities equals this value. Use a lower value for less
      random responses and a higher value for more random responses.
       */
  topP?: GenerateContentConfigInputTopP;
  /** For each token selection step, the ``top_k`` tokens with the
      highest probabilities are sampled. Then tokens are further filtered based
      on ``top_p`` with the final token selected using temperature sampling. Use
      a lower number for less random responses and a higher number for more
      random responses.
       */
  topK?: GenerateContentConfigInputTopK;
  /** Number of response variations to return.
   */
  candidateCount?: GenerateContentConfigInputCandidateCount;
  /** Maximum number of tokens that can be generated in the response.
   */
  maxOutputTokens?: GenerateContentConfigInputMaxOutputTokens;
  /** List of strings that tells the model to stop generating text if one
      of the strings is encountered in the response.
       */
  stopSequences?: GenerateContentConfigInputStopSequences;
  /** Whether to return the log probabilities of the tokens that were
      chosen by the model at each step.
       */
  responseLogprobs?: GenerateContentConfigInputResponseLogprobs;
  /** Number of top candidate tokens to return the log probabilities for
      at each generation step.
       */
  logprobs?: GenerateContentConfigInputLogprobs;
  /** Positive values penalize tokens that already appear in the
      generated text, increasing the probability of generating more diverse
      content.
       */
  presencePenalty?: GenerateContentConfigInputPresencePenalty;
  /** Positive values penalize tokens that repeatedly appear in the
      generated text, increasing the probability of generating more diverse
      content.
       */
  frequencyPenalty?: GenerateContentConfigInputFrequencyPenalty;
  /** When ``seed`` is fixed to a specific number, the model makes a best
      effort to provide the same response for repeated requests. By default, a
      random number is used.
       */
  seed?: GenerateContentConfigInputSeed;
  /** Output response mimetype of the generated candidate text.
      Supported mimetype:
        - `text/plain`: (default) Text output.
        - `application/json`: JSON response in the candidates.
      The model needs to be prompted to output the appropriate response type,
      otherwise the behavior is undefined.
      This is a preview feature.
       */
  responseMimeType?: GenerateContentConfigInputResponseMimeType;
  /** The `Schema` object allows the definition of input and output data types.
      These types can be objects, but also primitives and arrays.
      Represents a select subset of an [OpenAPI 3.0 schema
      object](https://spec.openapis.org/oas/v3.0.3#schema).
      If set, a compatible response_mime_type must also be set.
      Compatible mimetypes: `application/json`: Schema for JSON response.
       */
  responseSchema?: GenerateContentConfigInputResponseSchema;
  /** Optional. Output schema of the generated response.
      This is an alternative to `response_schema` that accepts [JSON
      Schema](https://json-schema.org/). If set, `response_schema` must be
      omitted, but `response_mime_type` is required. While the full JSON Schema
      may be sent, not all features are supported. Specifically, only the
      following properties are supported: - `$id` - `$defs` - `$ref` - `$anchor`
      - `type` - `format` - `title` - `description` - `enum` (for strings and
      numbers) - `items` - `prefixItems` - `minItems` - `maxItems` - `minimum` -
      `maximum` - `anyOf` - `oneOf` (interpreted the same as `anyOf`) -
      `properties` - `additionalProperties` - `required` The non-standard
      `propertyOrdering` property may also be set. Cyclic references are
      unrolled to a limited degree and, as such, may only be used within
      non-required properties. (Nullable properties are not sufficient.) If
      `$ref` is set on a sub-schema, no other properties, except for than those
      starting as a `$`, may be set. */
  responseJsonSchema?: GenerateContentConfigInputResponseJsonSchema;
  /** Configuration for model router requests.
   */
  routingConfig?: GenerateContentConfigInputRoutingConfig;
  /** Configuration for model selection.
   */
  modelSelectionConfig?: GenerateContentConfigInputModelSelectionConfig;
  /** Safety settings in the request to block unsafe content in the
      response.
       */
  safetySettings?: GenerateContentConfigInputSafetySettings;
  /** Code that enables the system to interact with external systems to
      perform an action outside of the knowledge and scope of the model.
       */
  tools?: GenerateContentConfigInputTools;
  /** Associates model output to a specific function call.
   */
  toolConfig?: GenerateContentConfigInputToolConfig;
  /** Labels with user-defined metadata to break down billed charges. */
  labels?: GenerateContentConfigInputLabels;
  /** Resource name of a context cache that can be used in subsequent
      requests.
       */
  cachedContent?: GenerateContentConfigInputCachedContent;
  /** The requested modalities of the response. Represents the set of
      modalities that the model can return.
       */
  responseModalities?: GenerateContentConfigInputResponseModalities;
  /** If specified, the media resolution specified will be used.
   */
  mediaResolution?: GenerateContentConfigInputMediaResolution;
  /** The speech generation configuration.
   */
  speechConfig?: GenerateContentConfigInputSpeechConfig;
  /** If enabled, audio timestamp will be included in the request to the
       model.
       */
  audioTimestamp?: GenerateContentConfigInputAudioTimestamp;
  /** The configuration for automatic function calling.
   */
  automaticFunctionCalling?: GenerateContentConfigInputAutomaticFunctionCalling;
  /** The thinking features configuration.
   */
  thinkingConfig?: GenerateContentConfigInputThinkingConfig;
}

/**
 * Used to override HTTP request options.
 */
export type GenerateContentConfigOutputHttpOptions = HttpOptions | null;

export type GenerateContentConfigOutputSystemInstructionAnyOfItem =
  | string
  | File
  | PartOutput;

/**
 * Instructions for the model to steer it toward better performance.
      For example, "Answer as concisely as possible" or "Don't use technical
      terms in your response".
      
 */
export type GenerateContentConfigOutputSystemInstruction =
  | ContentOutput
  | string
  | File
  | PartOutput
  | GenerateContentConfigOutputSystemInstructionAnyOfItem[]
  | null;

/**
 * Value that controls the degree of randomness in token selection.
      Lower temperatures are good for prompts that require a less open-ended or
      creative response, while higher temperatures can lead to more diverse or
      creative results.
      
 */
export type GenerateContentConfigOutputTemperature = number | null;

/**
 * Tokens are selected from the most to least probable until the sum
      of their probabilities equals this value. Use a lower value for less
      random responses and a higher value for more random responses.
      
 */
export type GenerateContentConfigOutputTopP = number | null;

/**
 * For each token selection step, the ``top_k`` tokens with the
      highest probabilities are sampled. Then tokens are further filtered based
      on ``top_p`` with the final token selected using temperature sampling. Use
      a lower number for less random responses and a higher number for more
      random responses.
      
 */
export type GenerateContentConfigOutputTopK = number | null;

/**
 * Number of response variations to return.
      
 */
export type GenerateContentConfigOutputCandidateCount = number | null;

/**
 * Maximum number of tokens that can be generated in the response.
      
 */
export type GenerateContentConfigOutputMaxOutputTokens = number | null;

/**
 * List of strings that tells the model to stop generating text if one
      of the strings is encountered in the response.
      
 */
export type GenerateContentConfigOutputStopSequences = string[] | null;

/**
 * Whether to return the log probabilities of the tokens that were
      chosen by the model at each step.
      
 */
export type GenerateContentConfigOutputResponseLogprobs = boolean | null;

/**
 * Number of top candidate tokens to return the log probabilities for
      at each generation step.
      
 */
export type GenerateContentConfigOutputLogprobs = number | null;

/**
 * Positive values penalize tokens that already appear in the
      generated text, increasing the probability of generating more diverse
      content.
      
 */
export type GenerateContentConfigOutputPresencePenalty = number | null;

/**
 * Positive values penalize tokens that repeatedly appear in the
      generated text, increasing the probability of generating more diverse
      content.
      
 */
export type GenerateContentConfigOutputFrequencyPenalty = number | null;

/**
 * When ``seed`` is fixed to a specific number, the model makes a best
      effort to provide the same response for repeated requests. By default, a
      random number is used.
      
 */
export type GenerateContentConfigOutputSeed = number | null;

/**
 * Output response mimetype of the generated candidate text.
      Supported mimetype:
        - `text/plain`: (default) Text output.
        - `application/json`: JSON response in the candidates.
      The model needs to be prompted to output the appropriate response type,
      otherwise the behavior is undefined.
      This is a preview feature.
      
 */
export type GenerateContentConfigOutputResponseMimeType = string | null;

export type GenerateContentConfigOutputResponseSchemaAnyOf = {
  [key: string]: unknown;
};

/**
 * The `Schema` object allows the definition of input and output data types.
      These types can be objects, but also primitives and arrays.
      Represents a select subset of an [OpenAPI 3.0 schema
      object](https://spec.openapis.org/oas/v3.0.3#schema).
      If set, a compatible response_mime_type must also be set.
      Compatible mimetypes: `application/json`: Schema for JSON response.
      
 */
export type GenerateContentConfigOutputResponseSchema =
  | GenerateContentConfigOutputResponseSchemaAnyOf
  | SchemaOutput
  | null;

/**
 * Optional. Output schema of the generated response.
      This is an alternative to `response_schema` that accepts [JSON
      Schema](https://json-schema.org/). If set, `response_schema` must be
      omitted, but `response_mime_type` is required. While the full JSON Schema
      may be sent, not all features are supported. Specifically, only the
      following properties are supported: - `$id` - `$defs` - `$ref` - `$anchor`
      - `type` - `format` - `title` - `description` - `enum` (for strings and
      numbers) - `items` - `prefixItems` - `minItems` - `maxItems` - `minimum` -
      `maximum` - `anyOf` - `oneOf` (interpreted the same as `anyOf`) -
      `properties` - `additionalProperties` - `required` The non-standard
      `propertyOrdering` property may also be set. Cyclic references are
      unrolled to a limited degree and, as such, may only be used within
      non-required properties. (Nullable properties are not sufficient.) If
      `$ref` is set on a sub-schema, no other properties, except for than those
      starting as a `$`, may be set.
 */
export type GenerateContentConfigOutputResponseJsonSchema = unknown | null;

/**
 * Configuration for model router requests.
      
 */
export type GenerateContentConfigOutputRoutingConfig =
  GenerationConfigRoutingConfig | null;

/**
 * Configuration for model selection.
      
 */
export type GenerateContentConfigOutputModelSelectionConfig =
  ModelSelectionConfig | null;

/**
 * Safety settings in the request to block unsafe content in the
      response.
      
 */
export type GenerateContentConfigOutputSafetySettings = SafetySetting[] | null;

export type GenerateContentConfigOutputToolsAnyOfItem =
  | GoogleGenaiTypesToolOutput
  | McpTypesTool;

/**
 * Code that enables the system to interact with external systems to
      perform an action outside of the knowledge and scope of the model.
      
 */
export type GenerateContentConfigOutputTools =
  | GenerateContentConfigOutputToolsAnyOfItem[]
  | null;

/**
 * Associates model output to a specific function call.
      
 */
export type GenerateContentConfigOutputToolConfig = ToolConfigOutput | null;

export type GenerateContentConfigOutputLabelsAnyOf = { [key: string]: string };

/**
 * Labels with user-defined metadata to break down billed charges.
 */
export type GenerateContentConfigOutputLabels =
  GenerateContentConfigOutputLabelsAnyOf | null;

/**
 * Resource name of a context cache that can be used in subsequent
      requests.
      
 */
export type GenerateContentConfigOutputCachedContent = string | null;

/**
 * The requested modalities of the response. Represents the set of
      modalities that the model can return.
      
 */
export type GenerateContentConfigOutputResponseModalities = string[] | null;

/**
 * If specified, the media resolution specified will be used.
    
 */
export type GenerateContentConfigOutputMediaResolution = MediaResolution | null;

/**
 * The speech generation configuration.
      
 */
export type GenerateContentConfigOutputSpeechConfig =
  | string
  | SpeechConfigOutput
  | null;

/**
 * If enabled, audio timestamp will be included in the request to the
       model.
      
 */
export type GenerateContentConfigOutputAudioTimestamp = boolean | null;

/**
 * The configuration for automatic function calling.
      
 */
export type GenerateContentConfigOutputAutomaticFunctionCalling =
  AutomaticFunctionCallingConfig | null;

/**
 * The thinking features configuration.
      
 */
export type GenerateContentConfigOutputThinkingConfig = ThinkingConfig | null;

/**
 * Optional model configuration parameters.

For more information, see `Content generation parameters
<https://cloud.google.com/vertex-ai/generative-ai/docs/multimodal/content-generation-parameters>`_.
 */
export interface GenerateContentConfigOutput {
  /** Used to override HTTP request options. */
  httpOptions?: GenerateContentConfigOutputHttpOptions;
  /** Instructions for the model to steer it toward better performance.
      For example, "Answer as concisely as possible" or "Don't use technical
      terms in your response".
       */
  systemInstruction?: GenerateContentConfigOutputSystemInstruction;
  /** Value that controls the degree of randomness in token selection.
      Lower temperatures are good for prompts that require a less open-ended or
      creative response, while higher temperatures can lead to more diverse or
      creative results.
       */
  temperature?: GenerateContentConfigOutputTemperature;
  /** Tokens are selected from the most to least probable until the sum
      of their probabilities equals this value. Use a lower value for less
      random responses and a higher value for more random responses.
       */
  topP?: GenerateContentConfigOutputTopP;
  /** For each token selection step, the ``top_k`` tokens with the
      highest probabilities are sampled. Then tokens are further filtered based
      on ``top_p`` with the final token selected using temperature sampling. Use
      a lower number for less random responses and a higher number for more
      random responses.
       */
  topK?: GenerateContentConfigOutputTopK;
  /** Number of response variations to return.
   */
  candidateCount?: GenerateContentConfigOutputCandidateCount;
  /** Maximum number of tokens that can be generated in the response.
   */
  maxOutputTokens?: GenerateContentConfigOutputMaxOutputTokens;
  /** List of strings that tells the model to stop generating text if one
      of the strings is encountered in the response.
       */
  stopSequences?: GenerateContentConfigOutputStopSequences;
  /** Whether to return the log probabilities of the tokens that were
      chosen by the model at each step.
       */
  responseLogprobs?: GenerateContentConfigOutputResponseLogprobs;
  /** Number of top candidate tokens to return the log probabilities for
      at each generation step.
       */
  logprobs?: GenerateContentConfigOutputLogprobs;
  /** Positive values penalize tokens that already appear in the
      generated text, increasing the probability of generating more diverse
      content.
       */
  presencePenalty?: GenerateContentConfigOutputPresencePenalty;
  /** Positive values penalize tokens that repeatedly appear in the
      generated text, increasing the probability of generating more diverse
      content.
       */
  frequencyPenalty?: GenerateContentConfigOutputFrequencyPenalty;
  /** When ``seed`` is fixed to a specific number, the model makes a best
      effort to provide the same response for repeated requests. By default, a
      random number is used.
       */
  seed?: GenerateContentConfigOutputSeed;
  /** Output response mimetype of the generated candidate text.
      Supported mimetype:
        - `text/plain`: (default) Text output.
        - `application/json`: JSON response in the candidates.
      The model needs to be prompted to output the appropriate response type,
      otherwise the behavior is undefined.
      This is a preview feature.
       */
  responseMimeType?: GenerateContentConfigOutputResponseMimeType;
  /** The `Schema` object allows the definition of input and output data types.
      These types can be objects, but also primitives and arrays.
      Represents a select subset of an [OpenAPI 3.0 schema
      object](https://spec.openapis.org/oas/v3.0.3#schema).
      If set, a compatible response_mime_type must also be set.
      Compatible mimetypes: `application/json`: Schema for JSON response.
       */
  responseSchema?: GenerateContentConfigOutputResponseSchema;
  /** Optional. Output schema of the generated response.
      This is an alternative to `response_schema` that accepts [JSON
      Schema](https://json-schema.org/). If set, `response_schema` must be
      omitted, but `response_mime_type` is required. While the full JSON Schema
      may be sent, not all features are supported. Specifically, only the
      following properties are supported: - `$id` - `$defs` - `$ref` - `$anchor`
      - `type` - `format` - `title` - `description` - `enum` (for strings and
      numbers) - `items` - `prefixItems` - `minItems` - `maxItems` - `minimum` -
      `maximum` - `anyOf` - `oneOf` (interpreted the same as `anyOf`) -
      `properties` - `additionalProperties` - `required` The non-standard
      `propertyOrdering` property may also be set. Cyclic references are
      unrolled to a limited degree and, as such, may only be used within
      non-required properties. (Nullable properties are not sufficient.) If
      `$ref` is set on a sub-schema, no other properties, except for than those
      starting as a `$`, may be set. */
  responseJsonSchema?: GenerateContentConfigOutputResponseJsonSchema;
  /** Configuration for model router requests.
   */
  routingConfig?: GenerateContentConfigOutputRoutingConfig;
  /** Configuration for model selection.
   */
  modelSelectionConfig?: GenerateContentConfigOutputModelSelectionConfig;
  /** Safety settings in the request to block unsafe content in the
      response.
       */
  safetySettings?: GenerateContentConfigOutputSafetySettings;
  /** Code that enables the system to interact with external systems to
      perform an action outside of the knowledge and scope of the model.
       */
  tools?: GenerateContentConfigOutputTools;
  /** Associates model output to a specific function call.
   */
  toolConfig?: GenerateContentConfigOutputToolConfig;
  /** Labels with user-defined metadata to break down billed charges. */
  labels?: GenerateContentConfigOutputLabels;
  /** Resource name of a context cache that can be used in subsequent
      requests.
       */
  cachedContent?: GenerateContentConfigOutputCachedContent;
  /** The requested modalities of the response. Represents the set of
      modalities that the model can return.
       */
  responseModalities?: GenerateContentConfigOutputResponseModalities;
  /** If specified, the media resolution specified will be used.
   */
  mediaResolution?: GenerateContentConfigOutputMediaResolution;
  /** The speech generation configuration.
   */
  speechConfig?: GenerateContentConfigOutputSpeechConfig;
  /** If enabled, audio timestamp will be included in the request to the
       model.
       */
  audioTimestamp?: GenerateContentConfigOutputAudioTimestamp;
  /** The configuration for automatic function calling.
   */
  automaticFunctionCalling?: GenerateContentConfigOutputAutomaticFunctionCalling;
  /** The thinking features configuration.
   */
  thinkingConfig?: GenerateContentConfigOutputThinkingConfig;
}

/**
 * Output only. List of modalities of the cached content in the request input.
 */
export type GenerateContentResponseUsageMetadataInputCacheTokensDetails =
  | ModalityTokenCount[]
  | null;

/**
 * Output only. Number of tokens in the cached part in the input (the cached content).
 */
export type GenerateContentResponseUsageMetadataInputCachedContentTokenCount =
  | number
  | null;

/**
 * Number of tokens in the response(s).
 */
export type GenerateContentResponseUsageMetadataInputCandidatesTokenCount =
  | number
  | null;

/**
 * Output only. List of modalities that were returned in the response.
 */
export type GenerateContentResponseUsageMetadataInputCandidatesTokensDetails =
  | ModalityTokenCount[]
  | null;

/**
 * Number of tokens in the request. When `cached_content` is set, this is still the total effective prompt size meaning this includes the number of tokens in the cached content.
 */
export type GenerateContentResponseUsageMetadataInputPromptTokenCount =
  | number
  | null;

/**
 * Output only. List of modalities that were processed in the request input.
 */
export type GenerateContentResponseUsageMetadataInputPromptTokensDetails =
  | ModalityTokenCount[]
  | null;

/**
 * Output only. Number of tokens present in thoughts output.
 */
export type GenerateContentResponseUsageMetadataInputThoughtsTokenCount =
  | number
  | null;

/**
 * Output only. Number of tokens present in tool-use prompt(s).
 */
export type GenerateContentResponseUsageMetadataInputToolUsePromptTokenCount =
  | number
  | null;

/**
 * Output only. List of modalities that were processed for tool-use request inputs.
 */
export type GenerateContentResponseUsageMetadataInputToolUsePromptTokensDetails =
  ModalityTokenCount[] | null;

/**
 * Total token count for prompt, response candidates, and tool-use prompts (if present).
 */
export type GenerateContentResponseUsageMetadataInputTotalTokenCount =
  | number
  | null;

/**
 * Output only. Traffic type. This shows whether a request consumes Pay-As-You-Go or Provisioned Throughput quota.
 */
export type GenerateContentResponseUsageMetadataInputTrafficType =
  TrafficType | null;

/**
 * Usage metadata about response(s).
 */
export interface GenerateContentResponseUsageMetadataInput {
  /** Output only. List of modalities of the cached content in the request input. */
  cacheTokensDetails?: GenerateContentResponseUsageMetadataInputCacheTokensDetails;
  /** Output only. Number of tokens in the cached part in the input (the cached content). */
  cachedContentTokenCount?: GenerateContentResponseUsageMetadataInputCachedContentTokenCount;
  /** Number of tokens in the response(s). */
  candidatesTokenCount?: GenerateContentResponseUsageMetadataInputCandidatesTokenCount;
  /** Output only. List of modalities that were returned in the response. */
  candidatesTokensDetails?: GenerateContentResponseUsageMetadataInputCandidatesTokensDetails;
  /** Number of tokens in the request. When `cached_content` is set, this is still the total effective prompt size meaning this includes the number of tokens in the cached content. */
  promptTokenCount?: GenerateContentResponseUsageMetadataInputPromptTokenCount;
  /** Output only. List of modalities that were processed in the request input. */
  promptTokensDetails?: GenerateContentResponseUsageMetadataInputPromptTokensDetails;
  /** Output only. Number of tokens present in thoughts output. */
  thoughtsTokenCount?: GenerateContentResponseUsageMetadataInputThoughtsTokenCount;
  /** Output only. Number of tokens present in tool-use prompt(s). */
  toolUsePromptTokenCount?: GenerateContentResponseUsageMetadataInputToolUsePromptTokenCount;
  /** Output only. List of modalities that were processed for tool-use request inputs. */
  toolUsePromptTokensDetails?: GenerateContentResponseUsageMetadataInputToolUsePromptTokensDetails;
  /** Total token count for prompt, response candidates, and tool-use prompts (if present). */
  totalTokenCount?: GenerateContentResponseUsageMetadataInputTotalTokenCount;
  /** Output only. Traffic type. This shows whether a request consumes Pay-As-You-Go or Provisioned Throughput quota. */
  trafficType?: GenerateContentResponseUsageMetadataInputTrafficType;
}

/**
 * Output only. List of modalities of the cached content in the request input.
 */
export type GenerateContentResponseUsageMetadataOutputCacheTokensDetails =
  | ModalityTokenCount[]
  | null;

/**
 * Output only. Number of tokens in the cached part in the input (the cached content).
 */
export type GenerateContentResponseUsageMetadataOutputCachedContentTokenCount =
  | number
  | null;

/**
 * Number of tokens in the response(s).
 */
export type GenerateContentResponseUsageMetadataOutputCandidatesTokenCount =
  | number
  | null;

/**
 * Output only. List of modalities that were returned in the response.
 */
export type GenerateContentResponseUsageMetadataOutputCandidatesTokensDetails =
  | ModalityTokenCount[]
  | null;

/**
 * Number of tokens in the request. When `cached_content` is set, this is still the total effective prompt size meaning this includes the number of tokens in the cached content.
 */
export type GenerateContentResponseUsageMetadataOutputPromptTokenCount =
  | number
  | null;

/**
 * Output only. List of modalities that were processed in the request input.
 */
export type GenerateContentResponseUsageMetadataOutputPromptTokensDetails =
  | ModalityTokenCount[]
  | null;

/**
 * Output only. Number of tokens present in thoughts output.
 */
export type GenerateContentResponseUsageMetadataOutputThoughtsTokenCount =
  | number
  | null;

/**
 * Output only. Number of tokens present in tool-use prompt(s).
 */
export type GenerateContentResponseUsageMetadataOutputToolUsePromptTokenCount =
  | number
  | null;

/**
 * Output only. List of modalities that were processed for tool-use request inputs.
 */
export type GenerateContentResponseUsageMetadataOutputToolUsePromptTokensDetails =
  ModalityTokenCount[] | null;

/**
 * Total token count for prompt, response candidates, and tool-use prompts (if present).
 */
export type GenerateContentResponseUsageMetadataOutputTotalTokenCount =
  | number
  | null;

/**
 * Output only. Traffic type. This shows whether a request consumes Pay-As-You-Go or Provisioned Throughput quota.
 */
export type GenerateContentResponseUsageMetadataOutputTrafficType =
  TrafficType | null;

/**
 * Usage metadata about response(s).
 */
export interface GenerateContentResponseUsageMetadataOutput {
  /** Output only. List of modalities of the cached content in the request input. */
  cacheTokensDetails?: GenerateContentResponseUsageMetadataOutputCacheTokensDetails;
  /** Output only. Number of tokens in the cached part in the input (the cached content). */
  cachedContentTokenCount?: GenerateContentResponseUsageMetadataOutputCachedContentTokenCount;
  /** Number of tokens in the response(s). */
  candidatesTokenCount?: GenerateContentResponseUsageMetadataOutputCandidatesTokenCount;
  /** Output only. List of modalities that were returned in the response. */
  candidatesTokensDetails?: GenerateContentResponseUsageMetadataOutputCandidatesTokensDetails;
  /** Number of tokens in the request. When `cached_content` is set, this is still the total effective prompt size meaning this includes the number of tokens in the cached content. */
  promptTokenCount?: GenerateContentResponseUsageMetadataOutputPromptTokenCount;
  /** Output only. List of modalities that were processed in the request input. */
  promptTokensDetails?: GenerateContentResponseUsageMetadataOutputPromptTokensDetails;
  /** Output only. Number of tokens present in thoughts output. */
  thoughtsTokenCount?: GenerateContentResponseUsageMetadataOutputThoughtsTokenCount;
  /** Output only. Number of tokens present in tool-use prompt(s). */
  toolUsePromptTokenCount?: GenerateContentResponseUsageMetadataOutputToolUsePromptTokenCount;
  /** Output only. List of modalities that were processed for tool-use request inputs. */
  toolUsePromptTokensDetails?: GenerateContentResponseUsageMetadataOutputToolUsePromptTokensDetails;
  /** Total token count for prompt, response candidates, and tool-use prompts (if present). */
  totalTokenCount?: GenerateContentResponseUsageMetadataOutputTotalTokenCount;
  /** Output only. Traffic type. This shows whether a request consumes Pay-As-You-Go or Provisioned Throughput quota. */
  trafficType?: GenerateContentResponseUsageMetadataOutputTrafficType;
}

/**
 * Automated routing.
 */
export type GenerationConfigRoutingConfigAutoMode =
  GenerationConfigRoutingConfigAutoRoutingMode | null;

/**
 * Manual routing.
 */
export type GenerationConfigRoutingConfigManualMode =
  GenerationConfigRoutingConfigManualRoutingMode | null;

/**
 * The configuration for routing the request to a specific model.
 */
export interface GenerationConfigRoutingConfig {
  /** Automated routing. */
  autoMode?: GenerationConfigRoutingConfigAutoMode;
  /** Manual routing. */
  manualMode?: GenerationConfigRoutingConfigManualMode;
}

/**
 * The model routing preference.
 */
export type GenerationConfigRoutingConfigAutoRoutingModeModelRoutingPreference =
  "UNKNOWN" | "PRIORITIZE_QUALITY" | "BALANCED" | "PRIORITIZE_COST" | null;

/**
 * When automated routing is specified, the routing will be determined by the pretrained routing model and customer provided model routing preference.
 */
export interface GenerationConfigRoutingConfigAutoRoutingMode {
  /** The model routing preference. */
  modelRoutingPreference?: GenerationConfigRoutingConfigAutoRoutingModeModelRoutingPreference;
}

/**
 * The model name to use. Only the public LLM models are accepted. See [Supported models](https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/inference#supported-models).
 */
export type GenerationConfigRoutingConfigManualRoutingModeModelName =
  | string
  | null;

/**
 * When manual routing is set, the specified model will be used directly.
 */
export interface GenerationConfigRoutingConfigManualRoutingMode {
  /** The model name to use. Only the public LLM models are accepted. See [Supported models](https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/inference#supported-models). */
  modelName?: GenerationConfigRoutingConfigManualRoutingModeModelName;
}

/**
 * Optional. Auth config for the Google Maps tool.
 */
export type GoogleMapsInputAuthConfig = GoogleGenaiTypesAuthConfig | null;

/**
 * Tool to support Google Maps in Model.
 */
export interface GoogleMapsInput {
  /** Optional. Auth config for the Google Maps tool. */
  authConfig?: GoogleMapsInputAuthConfig;
}

/**
 * Optional. Auth config for the Google Maps tool.
 */
export type GoogleMapsOutputAuthConfig = GoogleGenaiTypesAuthConfig | null;

/**
 * Tool to support Google Maps in Model.
 */
export interface GoogleMapsOutput {
  /** Optional. Auth config for the Google Maps tool. */
  authConfig?: GoogleMapsOutputAuthConfig;
}

/**
 * Optional. Filter search results to a specific time range.
      If customers set a start time, they must set an end time (and vice versa).
      
 */
export type GoogleSearchInputTimeRangeFilter = IntervalInput | null;

/**
 * Optional. List of domains to be excluded from the search results.
      The default limit is 2000 domains.
 */
export type GoogleSearchInputExcludeDomains = string[] | null;

/**
 * Tool to support Google Search in Model. Powered by Google.
 */
export interface GoogleSearchInput {
  /** Optional. Filter search results to a specific time range.
      If customers set a start time, they must set an end time (and vice versa).
       */
  timeRangeFilter?: GoogleSearchInputTimeRangeFilter;
  /** Optional. List of domains to be excluded from the search results.
      The default limit is 2000 domains. */
  excludeDomains?: GoogleSearchInputExcludeDomains;
}

/**
 * Optional. Filter search results to a specific time range.
      If customers set a start time, they must set an end time (and vice versa).
      
 */
export type GoogleSearchOutputTimeRangeFilter = GoogleGenaiTypesInterval | null;

/**
 * Optional. List of domains to be excluded from the search results.
      The default limit is 2000 domains.
 */
export type GoogleSearchOutputExcludeDomains = string[] | null;

/**
 * Tool to support Google Search in Model. Powered by Google.
 */
export interface GoogleSearchOutput {
  /** Optional. Filter search results to a specific time range.
      If customers set a start time, they must set an end time (and vice versa).
       */
  timeRangeFilter?: GoogleSearchOutputTimeRangeFilter;
  /** Optional. List of domains to be excluded from the search results.
      The default limit is 2000 domains. */
  excludeDomains?: GoogleSearchOutputExcludeDomains;
}

/**
 * Specifies the dynamic retrieval configuration for the given source.
 */
export type GoogleSearchRetrievalInputDynamicRetrievalConfig =
  DynamicRetrievalConfig | null;

/**
 * Tool to retrieve public web data for grounding, powered by Google.
 */
export interface GoogleSearchRetrievalInput {
  /** Specifies the dynamic retrieval configuration for the given source. */
  dynamicRetrievalConfig?: GoogleSearchRetrievalInputDynamicRetrievalConfig;
}

/**
 * Specifies the dynamic retrieval configuration for the given source.
 */
export type GoogleSearchRetrievalOutputDynamicRetrievalConfig =
  DynamicRetrievalConfig | null;

/**
 * Tool to retrieve public web data for grounding, powered by Google.
 */
export interface GoogleSearchRetrievalOutput {
  /** Specifies the dynamic retrieval configuration for the given source. */
  dynamicRetrievalConfig?: GoogleSearchRetrievalOutputDynamicRetrievalConfig;
}

/**
 * Grounding chunk from Google Maps.
 */
export type GroundingChunkInputMaps = GroundingChunkMapsInput | null;

/**
 * Grounding chunk from context retrieved by the retrieval tools.
 */
export type GroundingChunkInputRetrievedContext =
  GroundingChunkRetrievedContextInput | null;

/**
 * Grounding chunk from the web.
 */
export type GroundingChunkInputWeb = GroundingChunkWeb | null;

/**
 * Grounding chunk.
 */
export interface GroundingChunkInput {
  /** Grounding chunk from Google Maps. */
  maps?: GroundingChunkInputMaps;
  /** Grounding chunk from context retrieved by the retrieval tools. */
  retrievedContext?: GroundingChunkInputRetrievedContext;
  /** Grounding chunk from the web. */
  web?: GroundingChunkInputWeb;
}

/**
 * Grounding chunk from Google Maps.
 */
export type GroundingChunkOutputMaps = GroundingChunkMapsOutput | null;

/**
 * Grounding chunk from context retrieved by the retrieval tools.
 */
export type GroundingChunkOutputRetrievedContext =
  GroundingChunkRetrievedContextOutput | null;

/**
 * Grounding chunk from the web.
 */
export type GroundingChunkOutputWeb = GroundingChunkWeb | null;

/**
 * Grounding chunk.
 */
export interface GroundingChunkOutput {
  /** Grounding chunk from Google Maps. */
  maps?: GroundingChunkOutputMaps;
  /** Grounding chunk from context retrieved by the retrieval tools. */
  retrievedContext?: GroundingChunkOutputRetrievedContext;
  /** Grounding chunk from the web. */
  web?: GroundingChunkOutputWeb;
}

/**
 * Sources used to generate the place answer. This includes review snippets and photos that were used to generate the answer, as well as uris to flag content.
 */
export type GroundingChunkMapsInputPlaceAnswerSources =
  GroundingChunkMapsPlaceAnswerSourcesInput | null;

/**
 * This Place's resource name, in `places/{place_id}` format. Can be used to look up the Place.
 */
export type GroundingChunkMapsInputPlaceId = string | null;

/**
 * Text of the chunk.
 */
export type GroundingChunkMapsInputText = string | null;

/**
 * Title of the chunk.
 */
export type GroundingChunkMapsInputTitle = string | null;

/**
 * URI reference of the chunk.
 */
export type GroundingChunkMapsInputUri = string | null;

/**
 * Chunk from Google Maps.
 */
export interface GroundingChunkMapsInput {
  /** Sources used to generate the place answer. This includes review snippets and photos that were used to generate the answer, as well as uris to flag content. */
  placeAnswerSources?: GroundingChunkMapsInputPlaceAnswerSources;
  /** This Place's resource name, in `places/{place_id}` format. Can be used to look up the Place. */
  placeId?: GroundingChunkMapsInputPlaceId;
  /** Text of the chunk. */
  text?: GroundingChunkMapsInputText;
  /** Title of the chunk. */
  title?: GroundingChunkMapsInputTitle;
  /** URI reference of the chunk. */
  uri?: GroundingChunkMapsInputUri;
}

/**
 * Sources used to generate the place answer. This includes review snippets and photos that were used to generate the answer, as well as uris to flag content.
 */
export type GroundingChunkMapsOutputPlaceAnswerSources =
  GroundingChunkMapsPlaceAnswerSourcesOutput | null;

/**
 * This Place's resource name, in `places/{place_id}` format. Can be used to look up the Place.
 */
export type GroundingChunkMapsOutputPlaceId = string | null;

/**
 * Text of the chunk.
 */
export type GroundingChunkMapsOutputText = string | null;

/**
 * Title of the chunk.
 */
export type GroundingChunkMapsOutputTitle = string | null;

/**
 * URI reference of the chunk.
 */
export type GroundingChunkMapsOutputUri = string | null;

/**
 * Chunk from Google Maps.
 */
export interface GroundingChunkMapsOutput {
  /** Sources used to generate the place answer. This includes review snippets and photos that were used to generate the answer, as well as uris to flag content. */
  placeAnswerSources?: GroundingChunkMapsOutputPlaceAnswerSources;
  /** This Place's resource name, in `places/{place_id}` format. Can be used to look up the Place. */
  placeId?: GroundingChunkMapsOutputPlaceId;
  /** Text of the chunk. */
  text?: GroundingChunkMapsOutputText;
  /** Title of the chunk. */
  title?: GroundingChunkMapsOutputTitle;
  /** URI reference of the chunk. */
  uri?: GroundingChunkMapsOutputUri;
}

/**
 * A link where users can flag a problem with the generated answer.
 */
export type GroundingChunkMapsPlaceAnswerSourcesInputFlagContentUri =
  | string
  | null;

/**
 * Snippets of reviews that are used to generate the answer.
 */
export type GroundingChunkMapsPlaceAnswerSourcesInputReviewSnippets =
  | GroundingChunkMapsPlaceAnswerSourcesReviewSnippet[]
  | null;

/**
 * Sources used to generate the place answer.
 */
export interface GroundingChunkMapsPlaceAnswerSourcesInput {
  /** A link where users can flag a problem with the generated answer. */
  flagContentUri?: GroundingChunkMapsPlaceAnswerSourcesInputFlagContentUri;
  /** Snippets of reviews that are used to generate the answer. */
  reviewSnippets?: GroundingChunkMapsPlaceAnswerSourcesInputReviewSnippets;
}

/**
 * A link where users can flag a problem with the generated answer.
 */
export type GroundingChunkMapsPlaceAnswerSourcesOutputFlagContentUri =
  | string
  | null;

/**
 * Snippets of reviews that are used to generate the answer.
 */
export type GroundingChunkMapsPlaceAnswerSourcesOutputReviewSnippets =
  | GroundingChunkMapsPlaceAnswerSourcesReviewSnippet[]
  | null;

/**
 * Sources used to generate the place answer.
 */
export interface GroundingChunkMapsPlaceAnswerSourcesOutput {
  /** A link where users can flag a problem with the generated answer. */
  flagContentUri?: GroundingChunkMapsPlaceAnswerSourcesOutputFlagContentUri;
  /** Snippets of reviews that are used to generate the answer. */
  reviewSnippets?: GroundingChunkMapsPlaceAnswerSourcesOutputReviewSnippets;
}

/**
 * Name of the author of the Photo or Review.
 */
export type GroundingChunkMapsPlaceAnswerSourcesAuthorAttributionDisplayName =
  | string
  | null;

/**
 * Profile photo URI of the author of the Photo or Review.
 */
export type GroundingChunkMapsPlaceAnswerSourcesAuthorAttributionPhotoUri =
  | string
  | null;

/**
 * URI of the author of the Photo or Review.
 */
export type GroundingChunkMapsPlaceAnswerSourcesAuthorAttributionUri =
  | string
  | null;

/**
 * Author attribution for a photo or review.
 */
export interface GroundingChunkMapsPlaceAnswerSourcesAuthorAttribution {
  /** Name of the author of the Photo or Review. */
  displayName?: GroundingChunkMapsPlaceAnswerSourcesAuthorAttributionDisplayName;
  /** Profile photo URI of the author of the Photo or Review. */
  photoUri?: GroundingChunkMapsPlaceAnswerSourcesAuthorAttributionPhotoUri;
  /** URI of the author of the Photo or Review. */
  uri?: GroundingChunkMapsPlaceAnswerSourcesAuthorAttributionUri;
}

/**
 * This review's author.
 */
export type GroundingChunkMapsPlaceAnswerSourcesReviewSnippetAuthorAttribution =
  GroundingChunkMapsPlaceAnswerSourcesAuthorAttribution | null;

/**
 * A link where users can flag a problem with the review.
 */
export type GroundingChunkMapsPlaceAnswerSourcesReviewSnippetFlagContentUri =
  | string
  | null;

/**
 * A link to show the review on Google Maps.
 */
export type GroundingChunkMapsPlaceAnswerSourcesReviewSnippetGoogleMapsUri =
  | string
  | null;

/**
 * A string of formatted recent time, expressing the review time relative to the current time in a form appropriate for the language and country.
 */
export type GroundingChunkMapsPlaceAnswerSourcesReviewSnippetRelativePublishTimeDescription =
  string | null;

/**
 * A reference representing this place review which may be used to look up this place review again.
 */
export type GroundingChunkMapsPlaceAnswerSourcesReviewSnippetReview =
  | string
  | null;

/**
 * Encapsulates a review snippet.
 */
export interface GroundingChunkMapsPlaceAnswerSourcesReviewSnippet {
  /** This review's author. */
  authorAttribution?: GroundingChunkMapsPlaceAnswerSourcesReviewSnippetAuthorAttribution;
  /** A link where users can flag a problem with the review. */
  flagContentUri?: GroundingChunkMapsPlaceAnswerSourcesReviewSnippetFlagContentUri;
  /** A link to show the review on Google Maps. */
  googleMapsUri?: GroundingChunkMapsPlaceAnswerSourcesReviewSnippetGoogleMapsUri;
  /** A string of formatted recent time, expressing the review time relative to the current time in a form appropriate for the language and country. */
  relativePublishTimeDescription?: GroundingChunkMapsPlaceAnswerSourcesReviewSnippetRelativePublishTimeDescription;
  /** A reference representing this place review which may be used to look up this place review again. */
  review?: GroundingChunkMapsPlaceAnswerSourcesReviewSnippetReview;
}

/**
 * Output only. The full document name for the referenced Vertex AI Search document.
 */
export type GroundingChunkRetrievedContextInputDocumentName = string | null;

/**
 * Additional context for the RAG retrieval result. This is only populated when using the RAG retrieval tool.
 */
export type GroundingChunkRetrievedContextInputRagChunk = RagChunk | null;

/**
 * Text of the attribution.
 */
export type GroundingChunkRetrievedContextInputText = string | null;

/**
 * Title of the attribution.
 */
export type GroundingChunkRetrievedContextInputTitle = string | null;

/**
 * URI reference of the attribution.
 */
export type GroundingChunkRetrievedContextInputUri = string | null;

/**
 * Chunk from context retrieved by the retrieval tools.
 */
export interface GroundingChunkRetrievedContextInput {
  /** Output only. The full document name for the referenced Vertex AI Search document. */
  documentName?: GroundingChunkRetrievedContextInputDocumentName;
  /** Additional context for the RAG retrieval result. This is only populated when using the RAG retrieval tool. */
  ragChunk?: GroundingChunkRetrievedContextInputRagChunk;
  /** Text of the attribution. */
  text?: GroundingChunkRetrievedContextInputText;
  /** Title of the attribution. */
  title?: GroundingChunkRetrievedContextInputTitle;
  /** URI reference of the attribution. */
  uri?: GroundingChunkRetrievedContextInputUri;
}

/**
 * Output only. The full document name for the referenced Vertex AI Search document.
 */
export type GroundingChunkRetrievedContextOutputDocumentName = string | null;

/**
 * Additional context for the RAG retrieval result. This is only populated when using the RAG retrieval tool.
 */
export type GroundingChunkRetrievedContextOutputRagChunk = RagChunk | null;

/**
 * Text of the attribution.
 */
export type GroundingChunkRetrievedContextOutputText = string | null;

/**
 * Title of the attribution.
 */
export type GroundingChunkRetrievedContextOutputTitle = string | null;

/**
 * URI reference of the attribution.
 */
export type GroundingChunkRetrievedContextOutputUri = string | null;

/**
 * Chunk from context retrieved by the retrieval tools.
 */
export interface GroundingChunkRetrievedContextOutput {
  /** Output only. The full document name for the referenced Vertex AI Search document. */
  documentName?: GroundingChunkRetrievedContextOutputDocumentName;
  /** Additional context for the RAG retrieval result. This is only populated when using the RAG retrieval tool. */
  ragChunk?: GroundingChunkRetrievedContextOutputRagChunk;
  /** Text of the attribution. */
  text?: GroundingChunkRetrievedContextOutputText;
  /** Title of the attribution. */
  title?: GroundingChunkRetrievedContextOutputTitle;
  /** URI reference of the attribution. */
  uri?: GroundingChunkRetrievedContextOutputUri;
}

/**
 * Domain of the (original) URI.
 */
export type GroundingChunkWebDomain = string | null;

/**
 * Title of the chunk.
 */
export type GroundingChunkWebTitle = string | null;

/**
 * URI reference of the chunk.
 */
export type GroundingChunkWebUri = string | null;

/**
 * Chunk from the web.
 */
export interface GroundingChunkWeb {
  /** Domain of the (original) URI. */
  domain?: GroundingChunkWebDomain;
  /** Title of the chunk. */
  title?: GroundingChunkWebTitle;
  /** URI reference of the chunk. */
  uri?: GroundingChunkWebUri;
}

/**
 * Optional. Output only. Resource name of the Google Maps widget context token to be used with the PlacesContextElement widget to render contextual data. This is populated only for Google Maps grounding.
 */
export type GroundingMetadataInputGoogleMapsWidgetContextToken = string | null;

/**
 * List of supporting references retrieved from specified grounding source.
 */
export type GroundingMetadataInputGroundingChunks =
  | GroundingChunkInput[]
  | null;

/**
 * Optional. List of grounding support.
 */
export type GroundingMetadataInputGroundingSupports = GroundingSupport[] | null;

/**
 * Optional. Output only. Retrieval metadata.
 */
export type GroundingMetadataInputRetrievalMetadata = RetrievalMetadata | null;

/**
 * Optional. Queries executed by the retrieval tools.
 */
export type GroundingMetadataInputRetrievalQueries = string[] | null;

/**
 * Optional. Google search entry for the following-up web searches.
 */
export type GroundingMetadataInputSearchEntryPoint = SearchEntryPoint | null;

/**
 * Optional. Web search queries for the following-up web search.
 */
export type GroundingMetadataInputWebSearchQueries = string[] | null;

/**
 * Metadata returned to client when grounding is enabled.
 */
export interface GroundingMetadataInput {
  /** Optional. Output only. Resource name of the Google Maps widget context token to be used with the PlacesContextElement widget to render contextual data. This is populated only for Google Maps grounding. */
  googleMapsWidgetContextToken?: GroundingMetadataInputGoogleMapsWidgetContextToken;
  /** List of supporting references retrieved from specified grounding source. */
  groundingChunks?: GroundingMetadataInputGroundingChunks;
  /** Optional. List of grounding support. */
  groundingSupports?: GroundingMetadataInputGroundingSupports;
  /** Optional. Output only. Retrieval metadata. */
  retrievalMetadata?: GroundingMetadataInputRetrievalMetadata;
  /** Optional. Queries executed by the retrieval tools. */
  retrievalQueries?: GroundingMetadataInputRetrievalQueries;
  /** Optional. Google search entry for the following-up web searches. */
  searchEntryPoint?: GroundingMetadataInputSearchEntryPoint;
  /** Optional. Web search queries for the following-up web search. */
  webSearchQueries?: GroundingMetadataInputWebSearchQueries;
}

/**
 * Optional. Output only. Resource name of the Google Maps widget context token to be used with the PlacesContextElement widget to render contextual data. This is populated only for Google Maps grounding.
 */
export type GroundingMetadataOutputGoogleMapsWidgetContextToken = string | null;

/**
 * List of supporting references retrieved from specified grounding source.
 */
export type GroundingMetadataOutputGroundingChunks =
  | GroundingChunkOutput[]
  | null;

/**
 * Optional. List of grounding support.
 */
export type GroundingMetadataOutputGroundingSupports =
  | GroundingSupport[]
  | null;

/**
 * Optional. Output only. Retrieval metadata.
 */
export type GroundingMetadataOutputRetrievalMetadata = RetrievalMetadata | null;

/**
 * Optional. Queries executed by the retrieval tools.
 */
export type GroundingMetadataOutputRetrievalQueries = string[] | null;

/**
 * Optional. Google search entry for the following-up web searches.
 */
export type GroundingMetadataOutputSearchEntryPoint = SearchEntryPoint | null;

/**
 * Optional. Web search queries for the following-up web search.
 */
export type GroundingMetadataOutputWebSearchQueries = string[] | null;

/**
 * Metadata returned to client when grounding is enabled.
 */
export interface GroundingMetadataOutput {
  /** Optional. Output only. Resource name of the Google Maps widget context token to be used with the PlacesContextElement widget to render contextual data. This is populated only for Google Maps grounding. */
  googleMapsWidgetContextToken?: GroundingMetadataOutputGoogleMapsWidgetContextToken;
  /** List of supporting references retrieved from specified grounding source. */
  groundingChunks?: GroundingMetadataOutputGroundingChunks;
  /** Optional. List of grounding support. */
  groundingSupports?: GroundingMetadataOutputGroundingSupports;
  /** Optional. Output only. Retrieval metadata. */
  retrievalMetadata?: GroundingMetadataOutputRetrievalMetadata;
  /** Optional. Queries executed by the retrieval tools. */
  retrievalQueries?: GroundingMetadataOutputRetrievalQueries;
  /** Optional. Google search entry for the following-up web searches. */
  searchEntryPoint?: GroundingMetadataOutputSearchEntryPoint;
  /** Optional. Web search queries for the following-up web search. */
  webSearchQueries?: GroundingMetadataOutputWebSearchQueries;
}

/**
 * Confidence score of the support references. Ranges from 0 to 1. 1 is the most confident. For Gemini 2.0 and before, this list must have the same size as the grounding_chunk_indices. For Gemini 2.5 and after, this list will be empty and should be ignored.
 */
export type GroundingSupportConfidenceScores = number[] | null;

/**
 * A list of indices (into 'grounding_chunk') specifying the citations associated with the claim. For instance [1,3,4] means that grounding_chunk[1], grounding_chunk[3], grounding_chunk[4] are the retrieved content attributed to the claim.
 */
export type GroundingSupportGroundingChunkIndices = number[] | null;

/**
 * Segment of the content this support belongs to.
 */
export type GroundingSupportSegment = Segment | null;

/**
 * Grounding support.
 */
export interface GroundingSupport {
  /** Confidence score of the support references. Ranges from 0 to 1. 1 is the most confident. For Gemini 2.0 and before, this list must have the same size as the grounding_chunk_indices. For Gemini 2.5 and after, this list will be empty and should be ignored. */
  confidenceScores?: GroundingSupportConfidenceScores;
  /** A list of indices (into 'grounding_chunk') specifying the citations associated with the claim. For instance [1,3,4] means that grounding_chunk[1], grounding_chunk[3], grounding_chunk[4] are the retrieved content attributed to the claim. */
  groundingChunkIndices?: GroundingSupportGroundingChunkIndices;
  /** Segment of the content this support belongs to. */
  segment?: GroundingSupportSegment;
}

export type HTTPBaseDescription = string | null;

export interface HTTPBase {
  type?: SecuritySchemeType;
  description?: HTTPBaseDescription;
  scheme: string;
  [key: string]: unknown;
}

export type HTTPBearerDescription = string | null;

export type HTTPBearerBearerFormat = string | null;

export interface HTTPBearer {
  type?: SecuritySchemeType;
  description?: HTTPBearerDescription;
  scheme?: "bearer";
  bearerFormat?: HTTPBearerBearerFormat;
  [key: string]: unknown;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

/**
 * Optional.

Specify if the threshold is used for probability or severity score. If not
specified, the threshold is used for probability score.
 */
export type HarmBlockMethod =
  (typeof HarmBlockMethod)[keyof typeof HarmBlockMethod];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const HarmBlockMethod = {
  HARM_BLOCK_METHOD_UNSPECIFIED: "HARM_BLOCK_METHOD_UNSPECIFIED",
  SEVERITY: "SEVERITY",
  PROBABILITY: "PROBABILITY",
} as const;

/**
 * Required. The harm block threshold.
 */
export type HarmBlockThreshold =
  (typeof HarmBlockThreshold)[keyof typeof HarmBlockThreshold];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const HarmBlockThreshold = {
  HARM_BLOCK_THRESHOLD_UNSPECIFIED: "HARM_BLOCK_THRESHOLD_UNSPECIFIED",
  BLOCK_LOW_AND_ABOVE: "BLOCK_LOW_AND_ABOVE",
  BLOCK_MEDIUM_AND_ABOVE: "BLOCK_MEDIUM_AND_ABOVE",
  BLOCK_ONLY_HIGH: "BLOCK_ONLY_HIGH",
  BLOCK_NONE: "BLOCK_NONE",
  OFF: "OFF",
} as const;

/**
 * Required. Harm category.
 */
export type HarmCategory = (typeof HarmCategory)[keyof typeof HarmCategory];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const HarmCategory = {
  HARM_CATEGORY_UNSPECIFIED: "HARM_CATEGORY_UNSPECIFIED",
  HARM_CATEGORY_HATE_SPEECH: "HARM_CATEGORY_HATE_SPEECH",
  HARM_CATEGORY_DANGEROUS_CONTENT: "HARM_CATEGORY_DANGEROUS_CONTENT",
  HARM_CATEGORY_HARASSMENT: "HARM_CATEGORY_HARASSMENT",
  HARM_CATEGORY_SEXUALLY_EXPLICIT: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
  HARM_CATEGORY_CIVIC_INTEGRITY: "HARM_CATEGORY_CIVIC_INTEGRITY",
  HARM_CATEGORY_IMAGE_HATE: "HARM_CATEGORY_IMAGE_HATE",
  HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT:
    "HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT",
  HARM_CATEGORY_IMAGE_HARASSMENT: "HARM_CATEGORY_IMAGE_HARASSMENT",
  HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT:
    "HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT",
} as const;

/**
 * The credentials and metadata for HTTP authentication.
 */
export interface HttpAuth {
  scheme: string;
  credentials: HttpCredentials;
  [key: string]: unknown;
}

export type HttpCredentialsUsername = string | null;

export type HttpCredentialsPassword = string | null;

export type HttpCredentialsToken = string | null;

/**
 * Represents the secret token value for HTTP authentication, like user name, password, oauth token, etc.
 */
export interface HttpCredentials {
  username?: HttpCredentialsUsername;
  password?: HttpCredentialsPassword;
  token?: HttpCredentialsToken;
  [key: string]: unknown;
}

/**
 * The base URL for the AI platform service endpoint.
 */
export type HttpOptionsBaseUrl = string | null;

/**
 * Specifies the version of the API to use.
 */
export type HttpOptionsApiVersion = string | null;

export type HttpOptionsHeadersAnyOf = { [key: string]: string };

/**
 * Additional HTTP headers to be sent with the request.
 */
export type HttpOptionsHeaders = HttpOptionsHeadersAnyOf | null;

/**
 * Timeout for the request in milliseconds.
 */
export type HttpOptionsTimeout = number | null;

export type HttpOptionsClientArgsAnyOf = { [key: string]: unknown };

/**
 * Args passed to the HTTP client.
 */
export type HttpOptionsClientArgs = HttpOptionsClientArgsAnyOf | null;

export type HttpOptionsAsyncClientArgsAnyOf = { [key: string]: unknown };

/**
 * Args passed to the async HTTP client.
 */
export type HttpOptionsAsyncClientArgs = HttpOptionsAsyncClientArgsAnyOf | null;

export type HttpOptionsExtraBodyAnyOf = { [key: string]: unknown };

/**
 * Extra parameters to add to the request body.
      The structure must match the backend API's request structure.
      - VertexAI backend API docs: https://cloud.google.com/vertex-ai/docs/reference/rest
      - GeminiAPI backend API docs: https://ai.google.dev/api/rest
 */
export type HttpOptionsExtraBody = HttpOptionsExtraBodyAnyOf | null;

/**
 * HTTP retry options for the request.
 */
export type HttpOptionsRetryOptions = HttpRetryOptions | null;

/**
 * HTTP options to be used in each of the requests.
 */
export interface HttpOptions {
  /** The base URL for the AI platform service endpoint. */
  baseUrl?: HttpOptionsBaseUrl;
  /** Specifies the version of the API to use. */
  apiVersion?: HttpOptionsApiVersion;
  /** Additional HTTP headers to be sent with the request. */
  headers?: HttpOptionsHeaders;
  /** Timeout for the request in milliseconds. */
  timeout?: HttpOptionsTimeout;
  /** Args passed to the HTTP client. */
  clientArgs?: HttpOptionsClientArgs;
  /** Args passed to the async HTTP client. */
  asyncClientArgs?: HttpOptionsAsyncClientArgs;
  /** Extra parameters to add to the request body.
      The structure must match the backend API's request structure.
      - VertexAI backend API docs: https://cloud.google.com/vertex-ai/docs/reference/rest
      - GeminiAPI backend API docs: https://ai.google.dev/api/rest */
  extraBody?: HttpOptionsExtraBody;
  /** HTTP retry options for the request. */
  retryOptions?: HttpOptionsRetryOptions;
}

/**
 * Maximum number of attempts, including the original request.
      If 0 or 1, it means no retries.
 */
export type HttpRetryOptionsAttempts = number | null;

/**
 * Initial delay before the first retry, in fractions of a second.
 */
export type HttpRetryOptionsInitialDelay = number | null;

/**
 * Maximum delay between retries, in fractions of a second.
 */
export type HttpRetryOptionsMaxDelay = number | null;

/**
 * Multiplier by which the delay increases after each attempt.
 */
export type HttpRetryOptionsExpBase = number | null;

/**
 * Randomness factor for the delay.
 */
export type HttpRetryOptionsJitter = number | null;

/**
 * List of HTTP status codes that should trigger a retry.
      If not specified, a default set of retryable codes may be used.
 */
export type HttpRetryOptionsHttpStatusCodes = number[] | null;

/**
 * HTTP retry options to be used in each of the requests.
 */
export interface HttpRetryOptions {
  /** Maximum number of attempts, including the original request.
      If 0 or 1, it means no retries. */
  attempts?: HttpRetryOptionsAttempts;
  /** Initial delay before the first retry, in fractions of a second. */
  initialDelay?: HttpRetryOptionsInitialDelay;
  /** Maximum delay between retries, in fractions of a second. */
  maxDelay?: HttpRetryOptionsMaxDelay;
  /** Multiplier by which the delay increases after each attempt. */
  expBase?: HttpRetryOptionsExpBase;
  /** Randomness factor for the delay. */
  jitter?: HttpRetryOptionsJitter;
  /** List of HTTP status codes that should trigger a retry.
      If not specified, a default set of retryable codes may be used. */
  httpStatusCodes?: HttpRetryOptionsHttpStatusCodes;
}

/**
 * Container for intermediate data that an agent would generate as it responds with a final answer.
 */
export interface IntermediateDataInput {
  toolUses?: FunctionCall[];
  intermediateResponses?: [string, PartInput[]][];
}

/**
 * Container for intermediate data that an agent would generate as it responds with a final answer.
 */
export interface IntermediateDataOutput {
  toolUses?: FunctionCall[];
  intermediateResponses?: [string, PartOutput[]][];
}

/**
 * The start time of the interval.
 */
export type IntervalInputStartTime = string | null;

/**
 * The end time of the interval.
 */
export type IntervalInputEndTime = string | null;

/**
 * Represents a time interval, encoded as a start time (inclusive) and an end time (exclusive).

The start time must be less than or equal to the end time.
When the start equals the end time, the interval is an empty interval.
(matches no time)
When both start and end are unspecified, the interval matches any time.
 */
export interface IntervalInput {
  /** The start time of the interval. */
  startTime?: IntervalInputStartTime;
  /** The end time of the interval. */
  endTime?: IntervalInputEndTime;
}

export type InvocationInputFinalResponse = ContentInput | null;

export type InvocationInputIntermediateData = IntermediateDataInput | null;

/**
 * Represents a single invocation.
 */
export interface InvocationInput {
  invocationId?: string;
  userContent: ContentInput;
  finalResponse?: InvocationInputFinalResponse;
  intermediateData?: InvocationInputIntermediateData;
  creationTimestamp?: number;
}

export type InvocationOutputFinalResponse = ContentOutput | null;

export type InvocationOutputIntermediateData = IntermediateDataOutput | null;

/**
 * Represents a single invocation.
 */
export interface InvocationOutput {
  invocationId?: string;
  userContent: ContentOutput;
  finalResponse?: InvocationOutputFinalResponse;
  intermediateData?: InvocationOutputIntermediateData;
  creationTimestamp?: number;
}

/**
 * The configuration for the judge model.
 */
export type JudgeModelOptionsInputJudgeModelConfig =
  GenerateContentConfigInput | null;

/**
 * The number of times to sample the model for each invocation evaluation.
 */
export type JudgeModelOptionsInputNumSamples = number | null;

/**
 * Options for an eval metric's judge model.
 */
export interface JudgeModelOptionsInput {
  /** The judge model to use for evaluation. It can be a model name. */
  judge_model?: string;
  /** The configuration for the judge model. */
  judge_model_config?: JudgeModelOptionsInputJudgeModelConfig;
  /** The number of times to sample the model for each invocation evaluation. */
  num_samples?: JudgeModelOptionsInputNumSamples;
}

/**
 * The configuration for the judge model.
 */
export type JudgeModelOptionsOutputJudgeModelConfig =
  GenerateContentConfigOutput | null;

/**
 * The number of times to sample the model for each invocation evaluation.
 */
export type JudgeModelOptionsOutputNumSamples = number | null;

/**
 * Options for an eval metric's judge model.
 */
export interface JudgeModelOptionsOutput {
  /** The judge model to use for evaluation. It can be a model name. */
  judge_model?: string;
  /** The configuration for the judge model. */
  judge_model_config?: JudgeModelOptionsOutputJudgeModelConfig;
  /** The number of times to sample the model for each invocation evaluation. */
  num_samples?: JudgeModelOptionsOutputNumSamples;
}

/**
 * Required. Programming language of the `code`.
 */
export type Language = (typeof Language)[keyof typeof Language];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Language = {
  LANGUAGE_UNSPECIFIED: "LANGUAGE_UNSPECIFIED",
  PYTHON: "PYTHON",
} as const;

/**
 * The latitude in degrees. It must be in the range [-90.0, +90.0].
 */
export type LatLngLatitude = number | null;

/**
 * The longitude in degrees. It must be in the range [-180.0, +180.0]
 */
export type LatLngLongitude = number | null;

/**
 * An object that represents a latitude/longitude pair.

This is expressed as a pair of doubles to represent degrees latitude and
degrees longitude. Unless specified otherwise, this object must conform to the
<a href="https://en.wikipedia.org/wiki/World_Geodetic_System#1984_version">
WGS84 standard</a>. Values must be within normalized ranges.
 */
export interface LatLng {
  /** The latitude in degrees. It must be in the range [-90.0, +90.0]. */
  latitude?: LatLngLatitude;
  /** The longitude in degrees. It must be in the range [-180.0, +180.0] */
  longitude?: LatLngLongitude;
}

export interface ListEvalResultsResponse {
  evalResultIds: string[];
}

export interface ListEvalSetsResponse {
  evalSetIds: string[];
}

export interface ListMetricsInfoResponse {
  metricsInfo: MetricInfo[];
}

/**
 * New handle that represents state that can be resumed. Empty if `resumable`=false.
 */
export type LiveServerSessionResumptionUpdateNewHandle = string | null;

/**
 * True if session can be resumed at this point. It might be not possible to resume session at some points. In that case we send update empty new_handle and resumable=false. Example of such case could be model executing function calls or just generating. Resuming session (using previous session token) in such state will result in some data loss.
 */
export type LiveServerSessionResumptionUpdateResumable = boolean | null;

/**
 * Index of last message sent by client that is included in state represented by this SessionResumptionToken. Only sent when `SessionResumptionConfig.transparent` is set.

Presence of this index allows users to transparently reconnect and avoid issue of losing some part of realtime audio input/video. If client wishes to temporarily disconnect (for example as result of receiving GoAway) they can do it without losing state by buffering messages sent since last `SessionResmumptionTokenUpdate`. This field will enable them to limit buffering (avoid keeping all requests in RAM).

Note: This should not be used for when resuming a session at some time later -- in those cases partial audio and video frames arelikely not needed.
 */
export type LiveServerSessionResumptionUpdateLastConsumedClientMessageIndex =
  | number
  | null;

/**
 * Update of the session resumption state.

Only sent if `session_resumption` was set in the connection config.
 */
export interface LiveServerSessionResumptionUpdate {
  /** New handle that represents state that can be resumed. Empty if `resumable`=false. */
  newHandle?: LiveServerSessionResumptionUpdateNewHandle;
  /** True if session can be resumed at this point. It might be not possible to resume session at some points. In that case we send update empty new_handle and resumable=false. Example of such case could be model executing function calls or just generating. Resuming session (using previous session token) in such state will result in some data loss. */
  resumable?: LiveServerSessionResumptionUpdateResumable;
  /** Index of last message sent by client that is included in state represented by this SessionResumptionToken. Only sent when `SessionResumptionConfig.transparent` is set.

Presence of this index allows users to transparently reconnect and avoid issue of losing some part of realtime audio input/video. If client wishes to temporarily disconnect (for example as result of receiving GoAway) they can do it without losing state by buffering messages sent since last `SessionResmumptionTokenUpdate`. This field will enable them to limit buffering (avoid keeping all requests in RAM).

Note: This should not be used for when resuming a session at some time later -- in those cases partial audio and video frames arelikely not needed. */
  lastConsumedClientMessageIndex?: LiveServerSessionResumptionUpdateLastConsumedClientMessageIndex;
}

/**
 * Server content modalities.
 */
export type MediaModality = (typeof MediaModality)[keyof typeof MediaModality];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MediaModality = {
  MODALITY_UNSPECIFIED: "MODALITY_UNSPECIFIED",
  TEXT: "TEXT",
  IMAGE: "IMAGE",
  VIDEO: "VIDEO",
  AUDIO: "AUDIO",
  DOCUMENT: "DOCUMENT",
} as const;

/**
 * The media resolution to use.
 */
export type MediaResolution =
  (typeof MediaResolution)[keyof typeof MediaResolution];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MediaResolution = {
  MEDIA_RESOLUTION_UNSPECIFIED: "MEDIA_RESOLUTION_UNSPECIFIED",
  MEDIA_RESOLUTION_LOW: "MEDIA_RESOLUTION_LOW",
  MEDIA_RESOLUTION_MEDIUM: "MEDIA_RESOLUTION_MEDIUM",
  MEDIA_RESOLUTION_HIGH: "MEDIA_RESOLUTION_HIGH",
} as const;

/**
 * Information about the metric that are used for Evals.
 */
export interface MetricInfo {
  /** The name of the metric. */
  metricName: string;
  /** A 2 to 3 line description of the metric. */
  description?: string;
  /** Information on the nature of values supported by the metric. */
  metricValueInfo: MetricValueInfo;
}

/**
 * The values represented by the metric are of type interval.
 */
export type MetricValueInfoInterval =
  GoogleAdkEvaluationEvalMetricsInterval | null;

/**
 * Information about the type of metric value.
 */
export interface MetricValueInfo {
  /** The values represented by the metric are of type interval. */
  interval?: MetricValueInfoInterval;
}

/**
 * The modality associated with this token count.
 */
export type ModalityTokenCountModality = MediaModality | null;

/**
 * Number of tokens.
 */
export type ModalityTokenCountTokenCount = number | null;

/**
 * Represents token counting info for a single modality.
 */
export interface ModalityTokenCount {
  /** The modality associated with this token count. */
  modality?: ModalityTokenCountModality;
  /** Number of tokens. */
  tokenCount?: ModalityTokenCountTokenCount;
}

/**
 * Options for feature selection preference.
 */
export type ModelSelectionConfigFeatureSelectionPreference =
  FeatureSelectionPreference | null;

/**
 * Config for model selection.
 */
export interface ModelSelectionConfig {
  /** Options for feature selection preference. */
  featureSelectionPreference?: ModelSelectionConfigFeatureSelectionPreference;
}

/**
 * The configuration for the speaker to use.
 */
export type MultiSpeakerVoiceConfigInputSpeakerVoiceConfigs =
  | SpeakerVoiceConfigInput[]
  | null;

/**
 * The configuration for the multi-speaker setup.
 */
export interface MultiSpeakerVoiceConfigInput {
  /** The configuration for the speaker to use. */
  speakerVoiceConfigs?: MultiSpeakerVoiceConfigInputSpeakerVoiceConfigs;
}

/**
 * The configuration for the speaker to use.
 */
export type MultiSpeakerVoiceConfigOutputSpeakerVoiceConfigs =
  | SpeakerVoiceConfigOutput[]
  | null;

/**
 * The configuration for the multi-speaker setup.
 */
export interface MultiSpeakerVoiceConfigOutput {
  /** The configuration for the speaker to use. */
  speakerVoiceConfigs?: MultiSpeakerVoiceConfigOutputSpeakerVoiceConfigs;
}

export type OAuth2InputDescription = string | null;

export interface OAuth2Input {
  type?: SecuritySchemeType;
  description?: OAuth2InputDescription;
  flows: OAuthFlows;
  [key: string]: unknown;
}

export type OAuth2OutputDescription = string | null;

export interface OAuth2Output {
  type?: SecuritySchemeType;
  description?: OAuth2OutputDescription;
  flows: OAuthFlows;
  [key: string]: unknown;
}

export type OAuth2AuthClientId = string | null;

export type OAuth2AuthClientSecret = string | null;

export type OAuth2AuthAuthUri = string | null;

export type OAuth2AuthState = string | null;

export type OAuth2AuthRedirectUri = string | null;

export type OAuth2AuthAuthResponseUri = string | null;

export type OAuth2AuthAuthCode = string | null;

export type OAuth2AuthAccessToken = string | null;

export type OAuth2AuthRefreshToken = string | null;

export type OAuth2AuthExpiresAt = number | null;

export type OAuth2AuthExpiresIn = number | null;

/**
 * Represents credential value and its metadata for a OAuth2 credential.
 */
export interface OAuth2Auth {
  clientId?: OAuth2AuthClientId;
  clientSecret?: OAuth2AuthClientSecret;
  authUri?: OAuth2AuthAuthUri;
  state?: OAuth2AuthState;
  redirectUri?: OAuth2AuthRedirectUri;
  authResponseUri?: OAuth2AuthAuthResponseUri;
  authCode?: OAuth2AuthAuthCode;
  accessToken?: OAuth2AuthAccessToken;
  refreshToken?: OAuth2AuthRefreshToken;
  expiresAt?: OAuth2AuthExpiresAt;
  expiresIn?: OAuth2AuthExpiresIn;
  [key: string]: unknown;
}

export type OAuthFlowAuthorizationCodeRefreshUrl = string | null;

export type OAuthFlowAuthorizationCodeScopes = { [key: string]: string };

export interface OAuthFlowAuthorizationCode {
  refreshUrl?: OAuthFlowAuthorizationCodeRefreshUrl;
  scopes?: OAuthFlowAuthorizationCodeScopes;
  authorizationUrl: string;
  tokenUrl: string;
  [key: string]: unknown;
}

export type OAuthFlowClientCredentialsRefreshUrl = string | null;

export type OAuthFlowClientCredentialsScopes = { [key: string]: string };

export interface OAuthFlowClientCredentials {
  refreshUrl?: OAuthFlowClientCredentialsRefreshUrl;
  scopes?: OAuthFlowClientCredentialsScopes;
  tokenUrl: string;
  [key: string]: unknown;
}

export type OAuthFlowImplicitRefreshUrl = string | null;

export type OAuthFlowImplicitScopes = { [key: string]: string };

export interface OAuthFlowImplicit {
  refreshUrl?: OAuthFlowImplicitRefreshUrl;
  scopes?: OAuthFlowImplicitScopes;
  authorizationUrl: string;
  [key: string]: unknown;
}

export type OAuthFlowPasswordRefreshUrl = string | null;

export type OAuthFlowPasswordScopes = { [key: string]: string };

export interface OAuthFlowPassword {
  refreshUrl?: OAuthFlowPasswordRefreshUrl;
  scopes?: OAuthFlowPasswordScopes;
  tokenUrl: string;
  [key: string]: unknown;
}

export type OAuthFlowsImplicit = OAuthFlowImplicit | null;

export type OAuthFlowsPassword = OAuthFlowPassword | null;

export type OAuthFlowsClientCredentials = OAuthFlowClientCredentials | null;

export type OAuthFlowsAuthorizationCode = OAuthFlowAuthorizationCode | null;

export interface OAuthFlows {
  implicit?: OAuthFlowsImplicit;
  password?: OAuthFlowsPassword;
  clientCredentials?: OAuthFlowsClientCredentials;
  authorizationCode?: OAuthFlowsAuthorizationCode;
  [key: string]: unknown;
}

export type OpenIdConnectDescription = string | null;

export interface OpenIdConnect {
  type?: SecuritySchemeType;
  description?: OpenIdConnectDescription;
  openIdConnectUrl: string;
  [key: string]: unknown;
}

export type OpenIdConnectWithConfigDescription = string | null;

export type OpenIdConnectWithConfigUserinfoEndpoint = string | null;

export type OpenIdConnectWithConfigRevocationEndpoint = string | null;

export type OpenIdConnectWithConfigTokenEndpointAuthMethodsSupported =
  | string[]
  | null;

export type OpenIdConnectWithConfigGrantTypesSupported = string[] | null;

export type OpenIdConnectWithConfigScopes = string[] | null;

export interface OpenIdConnectWithConfig {
  type?: SecuritySchemeType;
  description?: OpenIdConnectWithConfigDescription;
  authorization_endpoint: string;
  token_endpoint: string;
  userinfo_endpoint?: OpenIdConnectWithConfigUserinfoEndpoint;
  revocation_endpoint?: OpenIdConnectWithConfigRevocationEndpoint;
  token_endpoint_auth_methods_supported?: OpenIdConnectWithConfigTokenEndpointAuthMethodsSupported;
  grant_types_supported?: OpenIdConnectWithConfigGrantTypesSupported;
  scopes?: OpenIdConnectWithConfigScopes;
  [key: string]: unknown;
}

/**
 * Required. Outcome of the code execution.
 */
export type Outcome = (typeof Outcome)[keyof typeof Outcome];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Outcome = {
  OUTCOME_UNSPECIFIED: "OUTCOME_UNSPECIFIED",
  OUTCOME_OK: "OUTCOME_OK",
  OUTCOME_FAILED: "OUTCOME_FAILED",
  OUTCOME_DEADLINE_EXCEEDED: "OUTCOME_DEADLINE_EXCEEDED",
} as const;

/**
 * Metadata for a given video.
 */
export type PartInputVideoMetadata = VideoMetadata | null;

/**
 * Indicates if the part is thought from the model.
 */
export type PartInputThought = boolean | null;

/**
 * Optional. Inlined bytes data.
 */
export type PartInputInlineData = Blob | null;

/**
 * Optional. URI based data.
 */
export type PartInputFileData = FileData | null;

/**
 * An opaque signature for the thought so it can be reused in subsequent requests.
 */
export type PartInputThoughtSignature = string | null;

/**
 * Optional. Result of executing the [ExecutableCode].
 */
export type PartInputCodeExecutionResult = CodeExecutionResult | null;

/**
 * Optional. Code generated by the model that is meant to be executed.
 */
export type PartInputExecutableCode = ExecutableCode | null;

/**
 * Optional. A predicted [FunctionCall] returned from the model that contains a string representing the [FunctionDeclaration.name] with the parameters and their values.
 */
export type PartInputFunctionCall = FunctionCall | null;

/**
 * Optional. The result output of a [FunctionCall] that contains a string representing the [FunctionDeclaration.name] and a structured JSON object containing any output from the function call. It is used as context to the model.
 */
export type PartInputFunctionResponse = FunctionResponse | null;

/**
 * Optional. Text part (can be code).
 */
export type PartInputText = string | null;

/**
 * A datatype containing media content.

Exactly one field within a Part should be set, representing the specific type
of content being conveyed. Using multiple fields within the same `Part`
instance is considered invalid.
 */
export interface PartInput {
  /** Metadata for a given video. */
  videoMetadata?: PartInputVideoMetadata;
  /** Indicates if the part is thought from the model. */
  thought?: PartInputThought;
  /** Optional. Inlined bytes data. */
  inlineData?: PartInputInlineData;
  /** Optional. URI based data. */
  fileData?: PartInputFileData;
  /** An opaque signature for the thought so it can be reused in subsequent requests. */
  thoughtSignature?: PartInputThoughtSignature;
  /** Optional. Result of executing the [ExecutableCode]. */
  codeExecutionResult?: PartInputCodeExecutionResult;
  /** Optional. Code generated by the model that is meant to be executed. */
  executableCode?: PartInputExecutableCode;
  /** Optional. A predicted [FunctionCall] returned from the model that contains a string representing the [FunctionDeclaration.name] with the parameters and their values. */
  functionCall?: PartInputFunctionCall;
  /** Optional. The result output of a [FunctionCall] that contains a string representing the [FunctionDeclaration.name] and a structured JSON object containing any output from the function call. It is used as context to the model. */
  functionResponse?: PartInputFunctionResponse;
  /** Optional. Text part (can be code). */
  text?: PartInputText;
}

/**
 * Metadata for a given video.
 */
export type PartOutputVideoMetadata = VideoMetadata | null;

/**
 * Indicates if the part is thought from the model.
 */
export type PartOutputThought = boolean | null;

/**
 * Optional. Inlined bytes data.
 */
export type PartOutputInlineData = Blob | null;

/**
 * Optional. URI based data.
 */
export type PartOutputFileData = FileData | null;

/**
 * An opaque signature for the thought so it can be reused in subsequent requests.
 */
export type PartOutputThoughtSignature = string | null;

/**
 * Optional. Result of executing the [ExecutableCode].
 */
export type PartOutputCodeExecutionResult = CodeExecutionResult | null;

/**
 * Optional. Code generated by the model that is meant to be executed.
 */
export type PartOutputExecutableCode = ExecutableCode | null;

/**
 * Optional. A predicted [FunctionCall] returned from the model that contains a string representing the [FunctionDeclaration.name] with the parameters and their values.
 */
export type PartOutputFunctionCall = FunctionCall | null;

/**
 * Optional. The result output of a [FunctionCall] that contains a string representing the [FunctionDeclaration.name] and a structured JSON object containing any output from the function call. It is used as context to the model.
 */
export type PartOutputFunctionResponse = FunctionResponse | null;

/**
 * Optional. Text part (can be code).
 */
export type PartOutputText = string | null;

/**
 * A datatype containing media content.

Exactly one field within a Part should be set, representing the specific type
of content being conveyed. Using multiple fields within the same `Part`
instance is considered invalid.
 */
export interface PartOutput {
  /** Metadata for a given video. */
  videoMetadata?: PartOutputVideoMetadata;
  /** Indicates if the part is thought from the model. */
  thought?: PartOutputThought;
  /** Optional. Inlined bytes data. */
  inlineData?: PartOutputInlineData;
  /** Optional. URI based data. */
  fileData?: PartOutputFileData;
  /** An opaque signature for the thought so it can be reused in subsequent requests. */
  thoughtSignature?: PartOutputThoughtSignature;
  /** Optional. Result of executing the [ExecutableCode]. */
  codeExecutionResult?: PartOutputCodeExecutionResult;
  /** Optional. Code generated by the model that is meant to be executed. */
  executableCode?: PartOutputExecutableCode;
  /** Optional. A predicted [FunctionCall] returned from the model that contains a string representing the [FunctionDeclaration.name] with the parameters and their values. */
  functionCall?: PartOutputFunctionCall;
  /** Optional. The result output of a [FunctionCall] that contains a string representing the [FunctionDeclaration.name] and a structured JSON object containing any output from the function call. It is used as context to the model. */
  functionResponse?: PartOutputFunctionResponse;
  /** Optional. Text part (can be code). */
  text?: PartOutputText;
}

/**
 * The name of the prebuilt voice to use.
 */
export type PrebuiltVoiceConfigVoiceName = string | null;

/**
 * The configuration for the prebuilt speaker to use.
 */
export interface PrebuiltVoiceConfig {
  /** The name of the prebuilt voice to use. */
  voiceName?: PrebuiltVoiceConfigVoiceName;
}

/**
 * If populated, represents where the chunk starts and ends in the document.
 */
export type RagChunkPageSpanProperty = RagChunkPageSpan | null;

/**
 * The content of the chunk.
 */
export type RagChunkText = string | null;

/**
 * A RagChunk includes the content of a chunk of a RagFile, and associated metadata.
 */
export interface RagChunk {
  /** If populated, represents where the chunk starts and ends in the document. */
  pageSpan?: RagChunkPageSpanProperty;
  /** The content of the chunk. */
  text?: RagChunkText;
}

/**
 * Page where chunk starts in the document. Inclusive. 1-indexed.
 */
export type RagChunkPageSpanFirstPage = number | null;

/**
 * Page where chunk ends in the document. Inclusive. 1-indexed.
 */
export type RagChunkPageSpanLastPage = number | null;

/**
 * Represents where the chunk starts and ends in the document.
 */
export interface RagChunkPageSpan {
  /** Page where chunk starts in the document. Inclusive. 1-indexed. */
  firstPage?: RagChunkPageSpanFirstPage;
  /** Page where chunk ends in the document. Inclusive. 1-indexed. */
  lastPage?: RagChunkPageSpanLastPage;
}

/**
 * Optional. Config for filters.
 */
export type RagRetrievalConfigInputFilter = RagRetrievalConfigFilter | null;

/**
 * Optional. Config for Hybrid Search.
 */
export type RagRetrievalConfigInputHybridSearch =
  RagRetrievalConfigHybridSearch | null;

/**
 * Optional. Config for ranking and reranking.
 */
export type RagRetrievalConfigInputRanking = RagRetrievalConfigRanking | null;

/**
 * Optional. The number of contexts to retrieve.
 */
export type RagRetrievalConfigInputTopK = number | null;

/**
 * Specifies the context retrieval config.
 */
export interface RagRetrievalConfigInput {
  /** Optional. Config for filters. */
  filter?: RagRetrievalConfigInputFilter;
  /** Optional. Config for Hybrid Search. */
  hybridSearch?: RagRetrievalConfigInputHybridSearch;
  /** Optional. Config for ranking and reranking. */
  ranking?: RagRetrievalConfigInputRanking;
  /** Optional. The number of contexts to retrieve. */
  topK?: RagRetrievalConfigInputTopK;
}

/**
 * Optional. Config for filters.
 */
export type RagRetrievalConfigOutputFilter = RagRetrievalConfigFilter | null;

/**
 * Optional. Config for Hybrid Search.
 */
export type RagRetrievalConfigOutputHybridSearch =
  RagRetrievalConfigHybridSearch | null;

/**
 * Optional. Config for ranking and reranking.
 */
export type RagRetrievalConfigOutputRanking = RagRetrievalConfigRanking | null;

/**
 * Optional. The number of contexts to retrieve.
 */
export type RagRetrievalConfigOutputTopK = number | null;

/**
 * Specifies the context retrieval config.
 */
export interface RagRetrievalConfigOutput {
  /** Optional. Config for filters. */
  filter?: RagRetrievalConfigOutputFilter;
  /** Optional. Config for Hybrid Search. */
  hybridSearch?: RagRetrievalConfigOutputHybridSearch;
  /** Optional. Config for ranking and reranking. */
  ranking?: RagRetrievalConfigOutputRanking;
  /** Optional. The number of contexts to retrieve. */
  topK?: RagRetrievalConfigOutputTopK;
}

/**
 * Optional. String for metadata filtering.
 */
export type RagRetrievalConfigFilterMetadataFilter = string | null;

/**
 * Optional. Only returns contexts with vector distance smaller than the threshold.
 */
export type RagRetrievalConfigFilterVectorDistanceThreshold = number | null;

/**
 * Optional. Only returns contexts with vector similarity larger than the threshold.
 */
export type RagRetrievalConfigFilterVectorSimilarityThreshold = number | null;

/**
 * Config for filters.
 */
export interface RagRetrievalConfigFilter {
  /** Optional. String for metadata filtering. */
  metadataFilter?: RagRetrievalConfigFilterMetadataFilter;
  /** Optional. Only returns contexts with vector distance smaller than the threshold. */
  vectorDistanceThreshold?: RagRetrievalConfigFilterVectorDistanceThreshold;
  /** Optional. Only returns contexts with vector similarity larger than the threshold. */
  vectorSimilarityThreshold?: RagRetrievalConfigFilterVectorSimilarityThreshold;
}

/**
 * Optional. Alpha value controls the weight between dense and sparse vector search results. The range is [0, 1], while 0 means sparse vector search only and 1 means dense vector search only. The default value is 0.5 which balances sparse and dense vector search equally.
 */
export type RagRetrievalConfigHybridSearchAlpha = number | null;

/**
 * Config for Hybrid Search.
 */
export interface RagRetrievalConfigHybridSearch {
  /** Optional. Alpha value controls the weight between dense and sparse vector search results. The range is [0, 1], while 0 means sparse vector search only and 1 means dense vector search only. The default value is 0.5 which balances sparse and dense vector search equally. */
  alpha?: RagRetrievalConfigHybridSearchAlpha;
}

/**
 * Optional. Config for LlmRanker.
 */
export type RagRetrievalConfigRankingLlmRankerProperty =
  RagRetrievalConfigRankingLlmRanker | null;

/**
 * Optional. Config for Rank Service.
 */
export type RagRetrievalConfigRankingRankServiceProperty =
  RagRetrievalConfigRankingRankService | null;

/**
 * Config for ranking and reranking.
 */
export interface RagRetrievalConfigRanking {
  /** Optional. Config for LlmRanker. */
  llmRanker?: RagRetrievalConfigRankingLlmRankerProperty;
  /** Optional. Config for Rank Service. */
  rankService?: RagRetrievalConfigRankingRankServiceProperty;
}

/**
 * Optional. The model name used for ranking. See [Supported models](https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/inference#supported-models).
 */
export type RagRetrievalConfigRankingLlmRankerModelName = string | null;

/**
 * Config for LlmRanker.
 */
export interface RagRetrievalConfigRankingLlmRanker {
  /** Optional. The model name used for ranking. See [Supported models](https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/inference#supported-models). */
  modelName?: RagRetrievalConfigRankingLlmRankerModelName;
}

/**
 * Optional. The model name of the rank service. Format: `semantic-ranker-512@latest`
 */
export type RagRetrievalConfigRankingRankServiceModelName = string | null;

/**
 * Config for Rank Service.
 */
export interface RagRetrievalConfigRankingRankService {
  /** Optional. The model name of the rank service. Format: `semantic-ranker-512@latest` */
  modelName?: RagRetrievalConfigRankingRankServiceModelName;
}

/**
 * Optional. Deprecated. This option is no longer supported.
 */
export type RetrievalInputDisableAttribution = boolean | null;

/**
 * Use data source powered by external API for grounding.
 */
export type RetrievalInputExternalApi = ExternalApiInput | null;

/**
 * Set to use data source powered by Vertex AI Search.
 */
export type RetrievalInputVertexAiSearch = VertexAISearch | null;

/**
 * Set to use data source powered by Vertex RAG store. User data is uploaded via the VertexRagDataService.
 */
export type RetrievalInputVertexRagStore = VertexRagStoreInput | null;

/**
 * Defines a retrieval tool that model can call to access external knowledge.
 */
export interface RetrievalInput {
  /** Optional. Deprecated. This option is no longer supported. */
  disableAttribution?: RetrievalInputDisableAttribution;
  /** Use data source powered by external API for grounding. */
  externalApi?: RetrievalInputExternalApi;
  /** Set to use data source powered by Vertex AI Search. */
  vertexAiSearch?: RetrievalInputVertexAiSearch;
  /** Set to use data source powered by Vertex RAG store. User data is uploaded via the VertexRagDataService. */
  vertexRagStore?: RetrievalInputVertexRagStore;
}

/**
 * Optional. Deprecated. This option is no longer supported.
 */
export type RetrievalOutputDisableAttribution = boolean | null;

/**
 * Use data source powered by external API for grounding.
 */
export type RetrievalOutputExternalApi = ExternalApiOutput | null;

/**
 * Set to use data source powered by Vertex AI Search.
 */
export type RetrievalOutputVertexAiSearch = VertexAISearch | null;

/**
 * Set to use data source powered by Vertex RAG store. User data is uploaded via the VertexRagDataService.
 */
export type RetrievalOutputVertexRagStore = VertexRagStoreOutput | null;

/**
 * Defines a retrieval tool that model can call to access external knowledge.
 */
export interface RetrievalOutput {
  /** Optional. Deprecated. This option is no longer supported. */
  disableAttribution?: RetrievalOutputDisableAttribution;
  /** Use data source powered by external API for grounding. */
  externalApi?: RetrievalOutputExternalApi;
  /** Set to use data source powered by Vertex AI Search. */
  vertexAiSearch?: RetrievalOutputVertexAiSearch;
  /** Set to use data source powered by Vertex RAG store. User data is uploaded via the VertexRagDataService. */
  vertexRagStore?: RetrievalOutputVertexRagStore;
}

/**
 * Optional. The location of the user.
 */
export type RetrievalConfigLatLng = LatLng | null;

/**
 * The language code of the user.
 */
export type RetrievalConfigLanguageCode = string | null;

/**
 * Retrieval config.
 */
export interface RetrievalConfig {
  /** Optional. The location of the user. */
  latLng?: RetrievalConfigLatLng;
  /** The language code of the user. */
  languageCode?: RetrievalConfigLanguageCode;
}

/**
 * Optional. Score indicating how likely information from Google Search could help answer the prompt. The score is in the range `[0, 1]`, where 0 is the least likely and 1 is the most likely. This score is only populated when Google Search grounding and dynamic retrieval is enabled. It will be compared to the threshold to determine whether to trigger Google Search.
 */
export type RetrievalMetadataGoogleSearchDynamicRetrievalScore = number | null;

/**
 * Metadata related to retrieval in the grounding flow.
 */
export interface RetrievalMetadata {
  /** Optional. Score indicating how likely information from Google Search could help answer the prompt. The score is in the range `[0, 1]`, where 0 is the least likely and 1 is the most likely. This score is only populated when Google Search grounding and dynamic retrieval is enabled. It will be compared to the threshold to determine whether to trigger Google Search. */
  googleSearchDynamicRetrievalScore?: RetrievalMetadataGoogleSearchDynamicRetrievalScore;
}

export type RunAgentRequestStateDeltaAnyOf = { [key: string]: unknown };

export type RunAgentRequestStateDelta = RunAgentRequestStateDeltaAnyOf | null;

export interface RunAgentRequest {
  appName: string;
  userId: string;
  sessionId: string;
  newMessage: ContentInput;
  streaming?: boolean;
  stateDelta?: RunAgentRequestStateDelta;
}

export interface RunEvalRequest {
  /**
   * This field is deprecated, use eval_case_ids instead.
   * @deprecated
   */
  evalIds?: string[];
  /** List of eval case ids to evaluate. if empty, then all eval cases in the eval set are run. */
  evalCaseIds?: string[];
  evalMetrics: EvalMetricInput[];
}

export interface RunEvalResponse {
  runEvalResults: RunEvalResult[];
}

export interface RunEvalResult {
  evalSetFile: string;
  evalSetId: string;
  evalId: string;
  finalEvalStatus: EvalStatus;
  /**
   * This field is deprecated, use overall_eval_metric_results instead.
   * @deprecated
   */
  evalMetricResults?: [EvalMetricOutput, EvalMetricResult][];
  overallEvalMetricResults: EvalMetricResult[];
  evalMetricResultPerInvocation: EvalMetricResultPerInvocation[];
  userId: string;
  sessionId: string;
}

/**
 * Determines if the harm block method uses probability or probability
      and severity scores.
 */
export type SafetySettingMethod = HarmBlockMethod | null;

/**
 * Required. Harm category.
 */
export type SafetySettingCategory = HarmCategory | null;

/**
 * Required. The harm block threshold.
 */
export type SafetySettingThreshold = HarmBlockThreshold | null;

/**
 * Safety settings.
 */
export interface SafetySetting {
  /** Determines if the harm block method uses probability or probability
      and severity scores. */
  method?: SafetySettingMethod;
  /** Required. Harm category. */
  category?: SafetySettingCategory;
  /** Required. The harm block threshold. */
  threshold?: SafetySettingThreshold;
}

/**
 * Optional. Can either be a boolean or an object; controls the presence of additional properties.
 */
export type SchemaInputAdditionalProperties = unknown | null;

export type SchemaInputDefsAnyOf = { [key: string]: SchemaInput };

/**
 * Optional. A map of definitions for use by `ref` Only allowed at the root of the schema.
 */
export type SchemaInputDefs = SchemaInputDefsAnyOf | null;

/**
 * Optional. Allows indirect references between schema nodes. The value should be a valid reference to a child of the root `defs`. For example, the following schema defines a reference to a schema node named "Pet": type: object properties: pet: ref: #/defs/Pet defs: Pet: type: object properties: name: type: string The value of the "pet" property is a reference to the schema node named "Pet". See details in https://json-schema.org/understanding-json-schema/structuring
 */
export type SchemaInputRef = string | null;

/**
 * Optional. The value should be validated against any (one or more) of the subschemas in the list.
 */
export type SchemaInputAnyOf = SchemaInput[] | null;

/**
 * Optional. Default value of the data.
 */
export type SchemaInputDefault = unknown | null;

/**
 * Optional. The description of the data.
 */
export type SchemaInputDescription = string | null;

/**
 * Optional. Possible values of the element of primitive type with enum format. Examples: 1. We can define direction as : {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]} 2. We can define apartment number as : {type:INTEGER, format:enum, enum:["101", "201", "301"]}
 */
export type SchemaInputEnum = string[] | null;

/**
 * Optional. Example of the object. Will only populated when the object is the root.
 */
export type SchemaInputExample = unknown | null;

/**
 * Optional. The format of the data. Supported formats: for NUMBER type: "float", "double" for INTEGER type: "int32", "int64" for STRING type: "email", "byte", etc
 */
export type SchemaInputFormat = string | null;

/**
 * Optional. SCHEMA FIELDS FOR TYPE ARRAY Schema of the elements of Type.ARRAY.
 */
export type SchemaInputItems = SchemaInput | null;

/**
 * Optional. Maximum number of the elements for Type.ARRAY.
 */
export type SchemaInputMaxItems = number | null;

/**
 * Optional. Maximum length of the Type.STRING
 */
export type SchemaInputMaxLength = number | null;

/**
 * Optional. Maximum number of the properties for Type.OBJECT.
 */
export type SchemaInputMaxProperties = number | null;

/**
 * Optional. Maximum value of the Type.INTEGER and Type.NUMBER
 */
export type SchemaInputMaximum = number | null;

/**
 * Optional. Minimum number of the elements for Type.ARRAY.
 */
export type SchemaInputMinItems = number | null;

/**
 * Optional. SCHEMA FIELDS FOR TYPE STRING Minimum length of the Type.STRING
 */
export type SchemaInputMinLength = number | null;

/**
 * Optional. Minimum number of the properties for Type.OBJECT.
 */
export type SchemaInputMinProperties = number | null;

/**
 * Optional. SCHEMA FIELDS FOR TYPE INTEGER and NUMBER Minimum value of the Type.INTEGER and Type.NUMBER
 */
export type SchemaInputMinimum = number | null;

/**
 * Optional. Indicates if the value may be null.
 */
export type SchemaInputNullable = boolean | null;

/**
 * Optional. Pattern of the Type.STRING to restrict a string to a regular expression.
 */
export type SchemaInputPattern = string | null;

export type SchemaInputPropertiesAnyOf = { [key: string]: SchemaInput };

/**
 * Optional. SCHEMA FIELDS FOR TYPE OBJECT Properties of Type.OBJECT.
 */
export type SchemaInputProperties = SchemaInputPropertiesAnyOf | null;

/**
 * Optional. The order of the properties. Not a standard field in open api spec. Only used to support the order of the properties.
 */
export type SchemaInputPropertyOrdering = string[] | null;

/**
 * Optional. Required properties of Type.OBJECT.
 */
export type SchemaInputRequired = string[] | null;

/**
 * Optional. The title of the Schema.
 */
export type SchemaInputTitle = string | null;

/**
 * Optional. The type of the data.
 */
export type SchemaInputType = Type | null;

/**
 * Schema is used to define the format of input/output data.

Represents a select subset of an [OpenAPI 3.0 schema
object](https://spec.openapis.org/oas/v3.0.3#schema-object). More fields may
be added in the future as needed.
 */
export interface SchemaInput {
  /** Optional. Can either be a boolean or an object; controls the presence of additional properties. */
  additionalProperties?: SchemaInputAdditionalProperties;
  /** Optional. A map of definitions for use by `ref` Only allowed at the root of the schema. */
  defs?: SchemaInputDefs;
  /** Optional. Allows indirect references between schema nodes. The value should be a valid reference to a child of the root `defs`. For example, the following schema defines a reference to a schema node named "Pet": type: object properties: pet: ref: #/defs/Pet defs: Pet: type: object properties: name: type: string The value of the "pet" property is a reference to the schema node named "Pet". See details in https://json-schema.org/understanding-json-schema/structuring */
  ref?: SchemaInputRef;
  /** Optional. The value should be validated against any (one or more) of the subschemas in the list. */
  anyOf?: SchemaInputAnyOf;
  /** Optional. Default value of the data. */
  default?: SchemaInputDefault;
  /** Optional. The description of the data. */
  description?: SchemaInputDescription;
  /** Optional. Possible values of the element of primitive type with enum format. Examples: 1. We can define direction as : {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]} 2. We can define apartment number as : {type:INTEGER, format:enum, enum:["101", "201", "301"]} */
  enum?: SchemaInputEnum;
  /** Optional. Example of the object. Will only populated when the object is the root. */
  example?: SchemaInputExample;
  /** Optional. The format of the data. Supported formats: for NUMBER type: "float", "double" for INTEGER type: "int32", "int64" for STRING type: "email", "byte", etc */
  format?: SchemaInputFormat;
  /** Optional. SCHEMA FIELDS FOR TYPE ARRAY Schema of the elements of Type.ARRAY. */
  items?: SchemaInputItems;
  /** Optional. Maximum number of the elements for Type.ARRAY. */
  maxItems?: SchemaInputMaxItems;
  /** Optional. Maximum length of the Type.STRING */
  maxLength?: SchemaInputMaxLength;
  /** Optional. Maximum number of the properties for Type.OBJECT. */
  maxProperties?: SchemaInputMaxProperties;
  /** Optional. Maximum value of the Type.INTEGER and Type.NUMBER */
  maximum?: SchemaInputMaximum;
  /** Optional. Minimum number of the elements for Type.ARRAY. */
  minItems?: SchemaInputMinItems;
  /** Optional. SCHEMA FIELDS FOR TYPE STRING Minimum length of the Type.STRING */
  minLength?: SchemaInputMinLength;
  /** Optional. Minimum number of the properties for Type.OBJECT. */
  minProperties?: SchemaInputMinProperties;
  /** Optional. SCHEMA FIELDS FOR TYPE INTEGER and NUMBER Minimum value of the Type.INTEGER and Type.NUMBER */
  minimum?: SchemaInputMinimum;
  /** Optional. Indicates if the value may be null. */
  nullable?: SchemaInputNullable;
  /** Optional. Pattern of the Type.STRING to restrict a string to a regular expression. */
  pattern?: SchemaInputPattern;
  /** Optional. SCHEMA FIELDS FOR TYPE OBJECT Properties of Type.OBJECT. */
  properties?: SchemaInputProperties;
  /** Optional. The order of the properties. Not a standard field in open api spec. Only used to support the order of the properties. */
  propertyOrdering?: SchemaInputPropertyOrdering;
  /** Optional. Required properties of Type.OBJECT. */
  required?: SchemaInputRequired;
  /** Optional. The title of the Schema. */
  title?: SchemaInputTitle;
  /** Optional. The type of the data. */
  type?: SchemaInputType;
}

/**
 * Optional. Can either be a boolean or an object; controls the presence of additional properties.
 */
export type SchemaOutputAdditionalProperties = unknown | null;

export type SchemaOutputDefsAnyOf = { [key: string]: SchemaOutput };

/**
 * Optional. A map of definitions for use by `ref` Only allowed at the root of the schema.
 */
export type SchemaOutputDefs = SchemaOutputDefsAnyOf | null;

/**
 * Optional. Allows indirect references between schema nodes. The value should be a valid reference to a child of the root `defs`. For example, the following schema defines a reference to a schema node named "Pet": type: object properties: pet: ref: #/defs/Pet defs: Pet: type: object properties: name: type: string The value of the "pet" property is a reference to the schema node named "Pet". See details in https://json-schema.org/understanding-json-schema/structuring
 */
export type SchemaOutputRef = string | null;

/**
 * Optional. The value should be validated against any (one or more) of the subschemas in the list.
 */
export type SchemaOutputAnyOf = SchemaOutput[] | null;

/**
 * Optional. Default value of the data.
 */
export type SchemaOutputDefault = unknown | null;

/**
 * Optional. The description of the data.
 */
export type SchemaOutputDescription = string | null;

/**
 * Optional. Possible values of the element of primitive type with enum format. Examples: 1. We can define direction as : {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]} 2. We can define apartment number as : {type:INTEGER, format:enum, enum:["101", "201", "301"]}
 */
export type SchemaOutputEnum = string[] | null;

/**
 * Optional. Example of the object. Will only populated when the object is the root.
 */
export type SchemaOutputExample = unknown | null;

/**
 * Optional. The format of the data. Supported formats: for NUMBER type: "float", "double" for INTEGER type: "int32", "int64" for STRING type: "email", "byte", etc
 */
export type SchemaOutputFormat = string | null;

/**
 * Optional. SCHEMA FIELDS FOR TYPE ARRAY Schema of the elements of Type.ARRAY.
 */
export type SchemaOutputItems = SchemaOutput | null;

/**
 * Optional. Maximum number of the elements for Type.ARRAY.
 */
export type SchemaOutputMaxItems = number | null;

/**
 * Optional. Maximum length of the Type.STRING
 */
export type SchemaOutputMaxLength = number | null;

/**
 * Optional. Maximum number of the properties for Type.OBJECT.
 */
export type SchemaOutputMaxProperties = number | null;

/**
 * Optional. Maximum value of the Type.INTEGER and Type.NUMBER
 */
export type SchemaOutputMaximum = number | null;

/**
 * Optional. Minimum number of the elements for Type.ARRAY.
 */
export type SchemaOutputMinItems = number | null;

/**
 * Optional. SCHEMA FIELDS FOR TYPE STRING Minimum length of the Type.STRING
 */
export type SchemaOutputMinLength = number | null;

/**
 * Optional. Minimum number of the properties for Type.OBJECT.
 */
export type SchemaOutputMinProperties = number | null;

/**
 * Optional. SCHEMA FIELDS FOR TYPE INTEGER and NUMBER Minimum value of the Type.INTEGER and Type.NUMBER
 */
export type SchemaOutputMinimum = number | null;

/**
 * Optional. Indicates if the value may be null.
 */
export type SchemaOutputNullable = boolean | null;

/**
 * Optional. Pattern of the Type.STRING to restrict a string to a regular expression.
 */
export type SchemaOutputPattern = string | null;

export type SchemaOutputPropertiesAnyOf = { [key: string]: SchemaOutput };

/**
 * Optional. SCHEMA FIELDS FOR TYPE OBJECT Properties of Type.OBJECT.
 */
export type SchemaOutputProperties = SchemaOutputPropertiesAnyOf | null;

/**
 * Optional. The order of the properties. Not a standard field in open api spec. Only used to support the order of the properties.
 */
export type SchemaOutputPropertyOrdering = string[] | null;

/**
 * Optional. Required properties of Type.OBJECT.
 */
export type SchemaOutputRequired = string[] | null;

/**
 * Optional. The title of the Schema.
 */
export type SchemaOutputTitle = string | null;

/**
 * Optional. The type of the data.
 */
export type SchemaOutputType = Type | null;

/**
 * Schema is used to define the format of input/output data.

Represents a select subset of an [OpenAPI 3.0 schema
object](https://spec.openapis.org/oas/v3.0.3#schema-object). More fields may
be added in the future as needed.
 */
export interface SchemaOutput {
  /** Optional. Can either be a boolean or an object; controls the presence of additional properties. */
  additionalProperties?: SchemaOutputAdditionalProperties;
  /** Optional. A map of definitions for use by `ref` Only allowed at the root of the schema. */
  defs?: SchemaOutputDefs;
  /** Optional. Allows indirect references between schema nodes. The value should be a valid reference to a child of the root `defs`. For example, the following schema defines a reference to a schema node named "Pet": type: object properties: pet: ref: #/defs/Pet defs: Pet: type: object properties: name: type: string The value of the "pet" property is a reference to the schema node named "Pet". See details in https://json-schema.org/understanding-json-schema/structuring */
  ref?: SchemaOutputRef;
  /** Optional. The value should be validated against any (one or more) of the subschemas in the list. */
  anyOf?: SchemaOutputAnyOf;
  /** Optional. Default value of the data. */
  default?: SchemaOutputDefault;
  /** Optional. The description of the data. */
  description?: SchemaOutputDescription;
  /** Optional. Possible values of the element of primitive type with enum format. Examples: 1. We can define direction as : {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]} 2. We can define apartment number as : {type:INTEGER, format:enum, enum:["101", "201", "301"]} */
  enum?: SchemaOutputEnum;
  /** Optional. Example of the object. Will only populated when the object is the root. */
  example?: SchemaOutputExample;
  /** Optional. The format of the data. Supported formats: for NUMBER type: "float", "double" for INTEGER type: "int32", "int64" for STRING type: "email", "byte", etc */
  format?: SchemaOutputFormat;
  /** Optional. SCHEMA FIELDS FOR TYPE ARRAY Schema of the elements of Type.ARRAY. */
  items?: SchemaOutputItems;
  /** Optional. Maximum number of the elements for Type.ARRAY. */
  maxItems?: SchemaOutputMaxItems;
  /** Optional. Maximum length of the Type.STRING */
  maxLength?: SchemaOutputMaxLength;
  /** Optional. Maximum number of the properties for Type.OBJECT. */
  maxProperties?: SchemaOutputMaxProperties;
  /** Optional. Maximum value of the Type.INTEGER and Type.NUMBER */
  maximum?: SchemaOutputMaximum;
  /** Optional. Minimum number of the elements for Type.ARRAY. */
  minItems?: SchemaOutputMinItems;
  /** Optional. SCHEMA FIELDS FOR TYPE STRING Minimum length of the Type.STRING */
  minLength?: SchemaOutputMinLength;
  /** Optional. Minimum number of the properties for Type.OBJECT. */
  minProperties?: SchemaOutputMinProperties;
  /** Optional. SCHEMA FIELDS FOR TYPE INTEGER and NUMBER Minimum value of the Type.INTEGER and Type.NUMBER */
  minimum?: SchemaOutputMinimum;
  /** Optional. Indicates if the value may be null. */
  nullable?: SchemaOutputNullable;
  /** Optional. Pattern of the Type.STRING to restrict a string to a regular expression. */
  pattern?: SchemaOutputPattern;
  /** Optional. SCHEMA FIELDS FOR TYPE OBJECT Properties of Type.OBJECT. */
  properties?: SchemaOutputProperties;
  /** Optional. The order of the properties. Not a standard field in open api spec. Only used to support the order of the properties. */
  propertyOrdering?: SchemaOutputPropertyOrdering;
  /** Optional. Required properties of Type.OBJECT. */
  required?: SchemaOutputRequired;
  /** Optional. The title of the Schema. */
  title?: SchemaOutputTitle;
  /** Optional. The type of the data. */
  type?: SchemaOutputType;
}

/**
 * Optional. Web content snippet that can be embedded in a web page or an app webview.
 */
export type SearchEntryPointRenderedContent = string | null;

/**
 * Optional. Base64 encoded JSON representing array of tuple.
 */
export type SearchEntryPointSdkBlob = string | null;

/**
 * Google search entry point.
 */
export interface SearchEntryPoint {
  /** Optional. Web content snippet that can be embedded in a web page or an app webview. */
  renderedContent?: SearchEntryPointRenderedContent;
  /** Optional. Base64 encoded JSON representing array of tuple. */
  sdkBlob?: SearchEntryPointSdkBlob;
}

export type SecuritySchemeType =
  (typeof SecuritySchemeType)[keyof typeof SecuritySchemeType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SecuritySchemeType = {
  apiKey: "apiKey",
  http: "http",
  oauth2: "oauth2",
  openIdConnect: "openIdConnect",
} as const;

/**
 * Output only. End index in the given Part, measured in bytes. Offset from the start of the Part, exclusive, starting at zero.
 */
export type SegmentEndIndex = number | null;

/**
 * Output only. The index of a Part object within its parent Content object.
 */
export type SegmentPartIndex = number | null;

/**
 * Output only. Start index in the given Part, measured in bytes. Offset from the start of the Part, inclusive, starting at zero.
 */
export type SegmentStartIndex = number | null;

/**
 * Output only. The text corresponding to the segment from the response.
 */
export type SegmentText = string | null;

/**
 * Segment of the content.
 */
export interface Segment {
  /** Output only. End index in the given Part, measured in bytes. Offset from the start of the Part, exclusive, starting at zero. */
  endIndex?: SegmentEndIndex;
  /** Output only. The index of a Part object within its parent Content object. */
  partIndex?: SegmentPartIndex;
  /** Output only. Start index in the given Part, measured in bytes. Offset from the start of the Part, inclusive, starting at zero. */
  startIndex?: SegmentStartIndex;
  /** Output only. The text corresponding to the segment from the response. */
  text?: SegmentText;
}

export type ServiceAccountServiceAccountCredential =
  ServiceAccountCredential | null;

export type ServiceAccountUseDefaultCredential = boolean | null;

/**
 * Represents Google Service Account configuration.
 */
export interface ServiceAccount {
  serviceAccountCredential?: ServiceAccountServiceAccountCredential;
  scopes: string[];
  useDefaultCredential?: ServiceAccountUseDefaultCredential;
  [key: string]: unknown;
}

/**
 * Represents Google Service Account configuration.

Attributes:
  type: The type should be "service_account".
  project_id: The project ID.
  private_key_id: The ID of the private key.
  private_key: The private key.
  client_email: The client email.
  client_id: The client ID.
  auth_uri: The authorization URI.
  token_uri: The token URI.
  auth_provider_x509_cert_url: URL for auth provider's X.509 cert.
  client_x509_cert_url: URL for the client's X.509 cert.
  universe_domain: The universe domain.

Example:

    config = ServiceAccountCredential(
        type_="service_account",
        project_id="your_project_id",
        private_key_id="your_private_key_id",
        private_key="-----BEGIN PRIVATE KEY-----...",
        client_email="...@....iam.gserviceaccount.com",
        client_id="your_client_id",
        auth_uri="https://accounts.google.com/o/oauth2/auth",
        token_uri="https://oauth2.googleapis.com/token",
        auth_provider_x509_cert_url="https://www.googleapis.com/oauth2/v1/certs",
        client_x509_cert_url="https://www.googleapis.com/robot/v1/metadata/x509/...",
        universe_domain="googleapis.com"
    )


    config = ServiceAccountConfig.model_construct(**{
        ...service account config dict
    })
 */
export interface ServiceAccountCredential {
  type?: string;
  projectId: string;
  privateKeyId: string;
  privateKey: string;
  clientEmail: string;
  clientId: string;
  authUri: string;
  tokenUri: string;
  authProviderX509CertUrl: string;
  clientX509CertUrl: string;
  universeDomain: string;
  [key: string]: unknown;
}

export type SessionState = { [key: string]: unknown };

/**
 * Represents a series of interactions between a user and agents.

Attributes:
  id: The unique identifier of the session.
  app_name: The name of the app.
  user_id: The id of the user.
  state: The state of the session.
  events: The events of the session, e.g. user input, model response, function
    call/response, etc.
  last_update_time: The last update time of the session.
 */
export interface Session {
  id: string;
  appName: string;
  userId: string;
  state?: SessionState;
  events?: EventOutput[];
  lastUpdateTime?: number;
}

export type SessionInputState = { [key: string]: unknown };

/**
 * Values that help initialize a Session.
 */
export interface SessionInput {
  appName: string;
  userId: string;
  state?: SessionInputState;
}

/**
 * The name of the speaker to use. Should be the same as in the
          prompt.
 */
export type SpeakerVoiceConfigInputSpeaker = string | null;

/**
 * The configuration for the voice to use.
 */
export type SpeakerVoiceConfigInputVoiceConfig = VoiceConfig | null;

/**
 * The configuration for the speaker to use.
 */
export interface SpeakerVoiceConfigInput {
  /** The name of the speaker to use. Should be the same as in the
          prompt. */
  speaker?: SpeakerVoiceConfigInputSpeaker;
  /** The configuration for the voice to use. */
  voiceConfig?: SpeakerVoiceConfigInputVoiceConfig;
}

/**
 * The name of the speaker to use. Should be the same as in the
          prompt.
 */
export type SpeakerVoiceConfigOutputSpeaker = string | null;

/**
 * The configuration for the voice to use.
 */
export type SpeakerVoiceConfigOutputVoiceConfig = VoiceConfig | null;

/**
 * The configuration for the speaker to use.
 */
export interface SpeakerVoiceConfigOutput {
  /** The name of the speaker to use. Should be the same as in the
          prompt. */
  speaker?: SpeakerVoiceConfigOutputSpeaker;
  /** The configuration for the voice to use. */
  voiceConfig?: SpeakerVoiceConfigOutputVoiceConfig;
}

/**
 * The configuration for the speaker to use.
      
 */
export type SpeechConfigInputVoiceConfig = VoiceConfig | null;

/**
 * The configuration for the multi-speaker setup.
          It is mutually exclusive with the voice_config field.
          
 */
export type SpeechConfigInputMultiSpeakerVoiceConfig =
  MultiSpeakerVoiceConfigInput | null;

/**
 * Language code (ISO 639. e.g. en-US) for the speech synthesization.
      Only available for Live API.
      
 */
export type SpeechConfigInputLanguageCode = string | null;

/**
 * The speech generation configuration.
 */
export interface SpeechConfigInput {
  /** The configuration for the speaker to use.
   */
  voiceConfig?: SpeechConfigInputVoiceConfig;
  /** The configuration for the multi-speaker setup.
          It is mutually exclusive with the voice_config field.
           */
  multiSpeakerVoiceConfig?: SpeechConfigInputMultiSpeakerVoiceConfig;
  /** Language code (ISO 639. e.g. en-US) for the speech synthesization.
      Only available for Live API.
       */
  languageCode?: SpeechConfigInputLanguageCode;
}

/**
 * The configuration for the speaker to use.
      
 */
export type SpeechConfigOutputVoiceConfig = VoiceConfig | null;

/**
 * The configuration for the multi-speaker setup.
          It is mutually exclusive with the voice_config field.
          
 */
export type SpeechConfigOutputMultiSpeakerVoiceConfig =
  MultiSpeakerVoiceConfigOutput | null;

/**
 * Language code (ISO 639. e.g. en-US) for the speech synthesization.
      Only available for Live API.
      
 */
export type SpeechConfigOutputLanguageCode = string | null;

/**
 * The speech generation configuration.
 */
export interface SpeechConfigOutput {
  /** The configuration for the speaker to use.
   */
  voiceConfig?: SpeechConfigOutputVoiceConfig;
  /** The configuration for the multi-speaker setup.
          It is mutually exclusive with the voice_config field.
           */
  multiSpeakerVoiceConfig?: SpeechConfigOutputMultiSpeakerVoiceConfig;
  /** Language code (ISO 639. e.g. en-US) for the speech synthesization.
      Only available for Live API.
       */
  languageCode?: SpeechConfigOutputLanguageCode;
}

/**
 * Indicates whether to include thoughts in the response. If true, thoughts are returned only if the model supports thought and thoughts are available.
      
 */
export type ThinkingConfigIncludeThoughts = boolean | null;

/**
 * Indicates the thinking budget in tokens. 0 is DISABLED. -1 is AUTOMATIC. The default values and allowed ranges are model dependent.
      
 */
export type ThinkingConfigThinkingBudget = number | null;

/**
 * The thinking features configuration.
 */
export interface ThinkingConfig {
  /** Indicates whether to include thoughts in the response. If true, thoughts are returned only if the model supports thought and thoughts are available.
   */
  includeThoughts?: ThinkingConfigIncludeThoughts;
  /** Indicates the thinking budget in tokens. 0 is DISABLED. -1 is AUTOMATIC. The default values and allowed ranges are model dependent.
   */
  thinkingBudget?: ThinkingConfigThinkingBudget;
}

export type ToolAnnotationsTitle = string | null;

export type ToolAnnotationsReadOnlyHint = boolean | null;

export type ToolAnnotationsDestructiveHint = boolean | null;

export type ToolAnnotationsIdempotentHint = boolean | null;

export type ToolAnnotationsOpenWorldHint = boolean | null;

/**
 * Additional properties describing a Tool to clients.

NOTE: all properties in ToolAnnotations are **hints**.
They are not guaranteed to provide a faithful description of
tool behavior (including descriptive properties like `title`).

Clients should never make tool use decisions based on ToolAnnotations
received from untrusted servers.
 */
export interface ToolAnnotations {
  title?: ToolAnnotationsTitle;
  readOnlyHint?: ToolAnnotationsReadOnlyHint;
  destructiveHint?: ToolAnnotationsDestructiveHint;
  idempotentHint?: ToolAnnotationsIdempotentHint;
  openWorldHint?: ToolAnnotationsOpenWorldHint;
  [key: string]: unknown;
}

/**
 * Tool that executes code generated by the model, and automatically returns the result to the model.

See also [ExecutableCode]and [CodeExecutionResult] which are input and output
to this tool.
 */
export interface ToolCodeExecution {
  [key: string]: unknown;
}

/**
 * Required. The environment being operated.
 */
export type ToolComputerUseEnvironment = Environment | null;

/**
 * Tool to support computer use.
 */
export interface ToolComputerUse {
  /** Required. The environment being operated. */
  environment?: ToolComputerUseEnvironment;
}

/**
 * Optional. Function calling config.
 */
export type ToolConfigInputFunctionCallingConfig = FunctionCallingConfig | null;

/**
 * Optional. Retrieval config.
 */
export type ToolConfigInputRetrievalConfig = RetrievalConfig | null;

/**
 * Tool config.

This config is shared for all tools provided in the request.
 */
export interface ToolConfigInput {
  /** Optional. Function calling config. */
  functionCallingConfig?: ToolConfigInputFunctionCallingConfig;
  /** Optional. Retrieval config. */
  retrievalConfig?: ToolConfigInputRetrievalConfig;
}

/**
 * Optional. Function calling config.
 */
export type ToolConfigOutputFunctionCallingConfig =
  FunctionCallingConfig | null;

/**
 * Optional. Retrieval config.
 */
export type ToolConfigOutputRetrievalConfig = RetrievalConfig | null;

/**
 * Tool config.

This config is shared for all tools provided in the request.
 */
export interface ToolConfigOutput {
  /** Optional. Function calling config. */
  functionCallingConfig?: ToolConfigOutputFunctionCallingConfig;
  /** Optional. Retrieval config. */
  retrievalConfig?: ToolConfigOutputRetrievalConfig;
}

/**
 * Output only.

Traffic type. This shows whether a request consumes Pay-As-You-Go or
Provisioned Throughput quota.
 */
export type TrafficType = (typeof TrafficType)[keyof typeof TrafficType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TrafficType = {
  TRAFFIC_TYPE_UNSPECIFIED: "TRAFFIC_TYPE_UNSPECIFIED",
  ON_DEMAND: "ON_DEMAND",
  PROVISIONED_THROUGHPUT: "PROVISIONED_THROUGHPUT",
} as const;

/**
 * Transcription text.
      
 */
export type TranscriptionText = string | null;

/**
 * The bool indicates the end of the transcription.
      
 */
export type TranscriptionFinished = boolean | null;

/**
 * Audio transcription in Server Conent.
 */
export interface Transcription {
  /** Transcription text.
   */
  text?: TranscriptionText;
  /** The bool indicates the end of the transcription.
   */
  finished?: TranscriptionFinished;
}

/**
 * Optional. The type of the data.
 */
export type Type = (typeof Type)[keyof typeof Type];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Type = {
  TYPE_UNSPECIFIED: "TYPE_UNSPECIFIED",
  STRING: "STRING",
  NUMBER: "NUMBER",
  INTEGER: "INTEGER",
  BOOLEAN: "BOOLEAN",
  ARRAY: "ARRAY",
  OBJECT: "OBJECT",
  NULL: "NULL",
} as const;

/**
 * Tool to support URL context retrieval.
 */
export interface UrlContext {
  [key: string]: unknown;
}

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

/**
 * Specifications that define the specific DataStores to be searched, along with configurations for those data stores. This is only considered for Engines with multiple data stores. It should only be set if engine is used.
 */
export type VertexAISearchDataStoreSpecs = VertexAISearchDataStoreSpec[] | null;

/**
 * Optional. Fully-qualified Vertex AI Search data store resource ID. Format: `projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}`
 */
export type VertexAISearchDatastore = string | null;

/**
 * Optional. Fully-qualified Vertex AI Search engine resource ID. Format: `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}`
 */
export type VertexAISearchEngine = string | null;

/**
 * Optional. Filter strings to be passed to the search API.
 */
export type VertexAISearchFilter = string | null;

/**
 * Optional. Number of search results to return per query. The default value is 10. The maximumm allowed value is 10.
 */
export type VertexAISearchMaxResults = number | null;

/**
 * Retrieve from Vertex AI Search datastore or engine for grounding.

datastore and engine are mutually exclusive. See
https://cloud.google.com/products/agent-builder
 */
export interface VertexAISearch {
  /** Specifications that define the specific DataStores to be searched, along with configurations for those data stores. This is only considered for Engines with multiple data stores. It should only be set if engine is used. */
  dataStoreSpecs?: VertexAISearchDataStoreSpecs;
  /** Optional. Fully-qualified Vertex AI Search data store resource ID. Format: `projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}` */
  datastore?: VertexAISearchDatastore;
  /** Optional. Fully-qualified Vertex AI Search engine resource ID. Format: `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}` */
  engine?: VertexAISearchEngine;
  /** Optional. Filter strings to be passed to the search API. */
  filter?: VertexAISearchFilter;
  /** Optional. Number of search results to return per query. The default value is 10. The maximumm allowed value is 10. */
  maxResults?: VertexAISearchMaxResults;
}

/**
 * Full resource name of DataStore, such as Format: `projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}`
 */
export type VertexAISearchDataStoreSpecDataStore = string | null;

/**
 * Optional. Filter specification to filter documents in the data store specified by data_store field. For more information on filtering, see [Filtering](https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata)
 */
export type VertexAISearchDataStoreSpecFilter = string | null;

/**
 * Define data stores within engine to filter on in a search call and configurations for those data stores.

For more information, see
https://cloud.google.com/generative-ai-app-builder/docs/reference/rpc/google.cloud.discoveryengine.v1#datastorespec
 */
export interface VertexAISearchDataStoreSpec {
  /** Full resource name of DataStore, such as Format: `projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}` */
  dataStore?: VertexAISearchDataStoreSpecDataStore;
  /** Optional. Filter specification to filter documents in the data store specified by data_store field. For more information on filtering, see [Filtering](https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata) */
  filter?: VertexAISearchDataStoreSpecFilter;
}

/**
 * Optional. Deprecated. Please use rag_resources instead.
 */
export type VertexRagStoreInputRagCorpora = string[] | null;

/**
 * Optional. The representation of the rag source. It can be used to specify corpus only or ragfiles. Currently only support one corpus or multiple files from one corpus. In the future we may open up multiple corpora support.
 */
export type VertexRagStoreInputRagResources =
  | VertexRagStoreRagResource[]
  | null;

/**
 * Optional. The retrieval config for the Rag query.
 */
export type VertexRagStoreInputRagRetrievalConfig =
  RagRetrievalConfigInput | null;

/**
 * Optional. Number of top k results to return from the selected corpora.
 */
export type VertexRagStoreInputSimilarityTopK = number | null;

/**
 * Optional. Currently only supported for Gemini Multimodal Live API. In Gemini Multimodal Live API, if `store_context` bool is specified, Gemini will leverage it to automatically memorize the interactions between the client and Gemini, and retrieve context when needed to augment the response generation for users' ongoing and future interactions.
 */
export type VertexRagStoreInputStoreContext = boolean | null;

/**
 * Optional. Only return results with vector distance smaller than the threshold.
 */
export type VertexRagStoreInputVectorDistanceThreshold = number | null;

/**
 * Retrieve from Vertex RAG Store for grounding.
 */
export interface VertexRagStoreInput {
  /** Optional. Deprecated. Please use rag_resources instead. */
  ragCorpora?: VertexRagStoreInputRagCorpora;
  /** Optional. The representation of the rag source. It can be used to specify corpus only or ragfiles. Currently only support one corpus or multiple files from one corpus. In the future we may open up multiple corpora support. */
  ragResources?: VertexRagStoreInputRagResources;
  /** Optional. The retrieval config for the Rag query. */
  ragRetrievalConfig?: VertexRagStoreInputRagRetrievalConfig;
  /** Optional. Number of top k results to return from the selected corpora. */
  similarityTopK?: VertexRagStoreInputSimilarityTopK;
  /** Optional. Currently only supported for Gemini Multimodal Live API. In Gemini Multimodal Live API, if `store_context` bool is specified, Gemini will leverage it to automatically memorize the interactions between the client and Gemini, and retrieve context when needed to augment the response generation for users' ongoing and future interactions. */
  storeContext?: VertexRagStoreInputStoreContext;
  /** Optional. Only return results with vector distance smaller than the threshold. */
  vectorDistanceThreshold?: VertexRagStoreInputVectorDistanceThreshold;
}

/**
 * Optional. Deprecated. Please use rag_resources instead.
 */
export type VertexRagStoreOutputRagCorpora = string[] | null;

/**
 * Optional. The representation of the rag source. It can be used to specify corpus only or ragfiles. Currently only support one corpus or multiple files from one corpus. In the future we may open up multiple corpora support.
 */
export type VertexRagStoreOutputRagResources =
  | VertexRagStoreRagResource[]
  | null;

/**
 * Optional. The retrieval config for the Rag query.
 */
export type VertexRagStoreOutputRagRetrievalConfig =
  RagRetrievalConfigOutput | null;

/**
 * Optional. Number of top k results to return from the selected corpora.
 */
export type VertexRagStoreOutputSimilarityTopK = number | null;

/**
 * Optional. Currently only supported for Gemini Multimodal Live API. In Gemini Multimodal Live API, if `store_context` bool is specified, Gemini will leverage it to automatically memorize the interactions between the client and Gemini, and retrieve context when needed to augment the response generation for users' ongoing and future interactions.
 */
export type VertexRagStoreOutputStoreContext = boolean | null;

/**
 * Optional. Only return results with vector distance smaller than the threshold.
 */
export type VertexRagStoreOutputVectorDistanceThreshold = number | null;

/**
 * Retrieve from Vertex RAG Store for grounding.
 */
export interface VertexRagStoreOutput {
  /** Optional. Deprecated. Please use rag_resources instead. */
  ragCorpora?: VertexRagStoreOutputRagCorpora;
  /** Optional. The representation of the rag source. It can be used to specify corpus only or ragfiles. Currently only support one corpus or multiple files from one corpus. In the future we may open up multiple corpora support. */
  ragResources?: VertexRagStoreOutputRagResources;
  /** Optional. The retrieval config for the Rag query. */
  ragRetrievalConfig?: VertexRagStoreOutputRagRetrievalConfig;
  /** Optional. Number of top k results to return from the selected corpora. */
  similarityTopK?: VertexRagStoreOutputSimilarityTopK;
  /** Optional. Currently only supported for Gemini Multimodal Live API. In Gemini Multimodal Live API, if `store_context` bool is specified, Gemini will leverage it to automatically memorize the interactions between the client and Gemini, and retrieve context when needed to augment the response generation for users' ongoing and future interactions. */
  storeContext?: VertexRagStoreOutputStoreContext;
  /** Optional. Only return results with vector distance smaller than the threshold. */
  vectorDistanceThreshold?: VertexRagStoreOutputVectorDistanceThreshold;
}

/**
 * Optional. RagCorpora resource name. Format: `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
 */
export type VertexRagStoreRagResourceRagCorpus = string | null;

/**
 * Optional. rag_file_id. The files should be in the same rag_corpus set in rag_corpus field.
 */
export type VertexRagStoreRagResourceRagFileIds = string[] | null;

/**
 * The definition of the Rag resource.
 */
export interface VertexRagStoreRagResource {
  /** Optional. RagCorpora resource name. Format: `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}` */
  ragCorpus?: VertexRagStoreRagResourceRagCorpus;
  /** Optional. rag_file_id. The files should be in the same rag_corpus set in rag_corpus field. */
  ragFileIds?: VertexRagStoreRagResourceRagFileIds;
}

/**
 * The frame rate of the video sent to the model. If not specified, the
        default value will be 1.0. The fps range is (0.0, 24.0].
 */
export type VideoMetadataFps = number | null;

/**
 * Optional. The end offset of the video.
 */
export type VideoMetadataEndOffset = string | null;

/**
 * Optional. The start offset of the video.
 */
export type VideoMetadataStartOffset = string | null;

/**
 * Describes how the video in the Part should be used by the model.
 */
export interface VideoMetadata {
  /** The frame rate of the video sent to the model. If not specified, the
        default value will be 1.0. The fps range is (0.0, 24.0]. */
  fps?: VideoMetadataFps;
  /** Optional. The end offset of the video. */
  endOffset?: VideoMetadataEndOffset;
  /** Optional. The start offset of the video. */
  startOffset?: VideoMetadataStartOffset;
}

/**
 * The configuration for the speaker to use.
      
 */
export type VoiceConfigPrebuiltVoiceConfig = PrebuiltVoiceConfig | null;

/**
 * The configuration for the voice to use.
 */
export interface VoiceConfig {
  /** The configuration for the speaker to use.
   */
  prebuiltVoiceConfig?: VoiceConfigPrebuiltVoiceConfig;
}

export type GoogleAdkAuthAuthToolAuthConfigInputAuthScheme =
  | APIKey
  | HTTPBase
  | OAuth2Input
  | OpenIdConnect
  | HTTPBearer
  | OpenIdConnectWithConfig;

export type GoogleAdkAuthAuthToolAuthConfigInputRawAuthCredential =
  AuthCredentialInput | null;

export type GoogleAdkAuthAuthToolAuthConfigInputExchangedAuthCredential =
  AuthCredentialInput | null;

export type GoogleAdkAuthAuthToolAuthConfigInputCredentialKey = string | null;

/**
 * The auth config sent by tool asking client to collect auth credentials and

adk and client will help to fill in the response
 */
export interface GoogleAdkAuthAuthToolAuthConfigInput {
  authScheme: GoogleAdkAuthAuthToolAuthConfigInputAuthScheme;
  rawAuthCredential?: GoogleAdkAuthAuthToolAuthConfigInputRawAuthCredential;
  exchangedAuthCredential?: GoogleAdkAuthAuthToolAuthConfigInputExchangedAuthCredential;
  credentialKey?: GoogleAdkAuthAuthToolAuthConfigInputCredentialKey;
  [key: string]: unknown;
}

export type GoogleAdkAuthAuthToolAuthConfigOutputAuthScheme =
  | APIKey
  | HTTPBase
  | OAuth2Output
  | OpenIdConnect
  | HTTPBearer
  | OpenIdConnectWithConfig;

export type GoogleAdkAuthAuthToolAuthConfigOutputRawAuthCredential =
  AuthCredentialOutput | null;

export type GoogleAdkAuthAuthToolAuthConfigOutputExchangedAuthCredential =
  AuthCredentialOutput | null;

export type GoogleAdkAuthAuthToolAuthConfigOutputCredentialKey = string | null;

/**
 * The auth config sent by tool asking client to collect auth credentials and

adk and client will help to fill in the response
 */
export interface GoogleAdkAuthAuthToolAuthConfigOutput {
  authScheme: GoogleAdkAuthAuthToolAuthConfigOutputAuthScheme;
  rawAuthCredential?: GoogleAdkAuthAuthToolAuthConfigOutputRawAuthCredential;
  exchangedAuthCredential?: GoogleAdkAuthAuthToolAuthConfigOutputExchangedAuthCredential;
  credentialKey?: GoogleAdkAuthAuthToolAuthConfigOutputCredentialKey;
  [key: string]: unknown;
}

/**
 * Represents a range of numeric values, e.g. [0 ,1] or (2,3) or [-1, 6).
 */
export interface GoogleAdkEvaluationEvalMetricsInterval {
  /** The smaller end of the interval. */
  min_value: number;
  /** The interval is Open on the min end. The default value is False, which means that we assume that the interval is Closed. */
  open_at_min?: boolean;
  /** The larger end of the interval. */
  max_value: number;
  /** The interval is Open on the max end. The default value is False, which means that we assume that the interval is Closed. */
  open_at_max?: boolean;
}

/**
 * Config for API key auth.
 */
export type GoogleGenaiTypesAuthConfigApiKeyConfig = ApiKeyConfig | null;

/**
 * Type of auth scheme.
 */
export type GoogleGenaiTypesAuthConfigAuthType = AuthType | null;

/**
 * Config for Google Service Account auth.
 */
export type GoogleGenaiTypesAuthConfigGoogleServiceAccountConfig =
  AuthConfigGoogleServiceAccountConfig | null;

/**
 * Config for HTTP Basic auth.
 */
export type GoogleGenaiTypesAuthConfigHttpBasicAuthConfig =
  AuthConfigHttpBasicAuthConfig | null;

/**
 * Config for user oauth.
 */
export type GoogleGenaiTypesAuthConfigOauthConfig =
  AuthConfigOauthConfig | null;

/**
 * Config for user OIDC auth.
 */
export type GoogleGenaiTypesAuthConfigOidcConfig = AuthConfigOidcConfig | null;

/**
 * Auth configuration to run the extension.
 */
export interface GoogleGenaiTypesAuthConfig {
  /** Config for API key auth. */
  apiKeyConfig?: GoogleGenaiTypesAuthConfigApiKeyConfig;
  /** Type of auth scheme. */
  authType?: GoogleGenaiTypesAuthConfigAuthType;
  /** Config for Google Service Account auth. */
  googleServiceAccountConfig?: GoogleGenaiTypesAuthConfigGoogleServiceAccountConfig;
  /** Config for HTTP Basic auth. */
  httpBasicAuthConfig?: GoogleGenaiTypesAuthConfigHttpBasicAuthConfig;
  /** Config for user oauth. */
  oauthConfig?: GoogleGenaiTypesAuthConfigOauthConfig;
  /** Config for user OIDC auth. */
  oidcConfig?: GoogleGenaiTypesAuthConfigOidcConfig;
}

/**
 * The start time of the interval.
 */
export type GoogleGenaiTypesIntervalStartTime = string | null;

/**
 * The end time of the interval.
 */
export type GoogleGenaiTypesIntervalEndTime = string | null;

/**
 * Represents a time interval, encoded as a start time (inclusive) and an end time (exclusive).

The start time must be less than or equal to the end time.
When the start equals the end time, the interval is an empty interval.
(matches no time)
When both start and end are unspecified, the interval matches any time.
 */
export interface GoogleGenaiTypesInterval {
  /** The start time of the interval. */
  startTime?: GoogleGenaiTypesIntervalStartTime;
  /** The end time of the interval. */
  endTime?: GoogleGenaiTypesIntervalEndTime;
}

/**
 * List of function declarations that the tool supports.
 */
export type GoogleGenaiTypesToolInputFunctionDeclarations =
  | FunctionDeclarationInput[]
  | null;

/**
 * Optional. Retrieval tool type. System will always execute the provided retrieval tool(s) to get external knowledge to answer the prompt. Retrieval results are presented to the model for generation.
 */
export type GoogleGenaiTypesToolInputRetrieval = RetrievalInput | null;

/**
 * Optional. Google Search tool type. Specialized retrieval tool
      that is powered by Google Search.
 */
export type GoogleGenaiTypesToolInputGoogleSearch = GoogleSearchInput | null;

/**
 * Optional. GoogleSearchRetrieval tool type. Specialized retrieval tool that is powered by Google search.
 */
export type GoogleGenaiTypesToolInputGoogleSearchRetrieval =
  GoogleSearchRetrievalInput | null;

/**
 * Optional. Enterprise web search tool type. Specialized retrieval
      tool that is powered by Vertex AI Search and Sec4 compliance.
 */
export type GoogleGenaiTypesToolInputEnterpriseWebSearch =
  EnterpriseWebSearch | null;

/**
 * Optional. Google Maps tool type. Specialized retrieval tool
      that is powered by Google Maps.
 */
export type GoogleGenaiTypesToolInputGoogleMaps = GoogleMapsInput | null;

/**
 * Optional. Tool to support URL context retrieval.
 */
export type GoogleGenaiTypesToolInputUrlContext = UrlContext | null;

/**
 * Optional. Tool to support the model interacting directly with the
      computer. If enabled, it automatically populates computer-use specific
      Function Declarations.
 */
export type GoogleGenaiTypesToolInputComputerUse = ToolComputerUse | null;

/**
 * Optional. CodeExecution tool type. Enables the model to execute code as part of generation.
 */
export type GoogleGenaiTypesToolInputCodeExecution = ToolCodeExecution | null;

/**
 * Tool details of a tool that the model may use to generate a response.
 */
export interface GoogleGenaiTypesToolInput {
  /** List of function declarations that the tool supports. */
  functionDeclarations?: GoogleGenaiTypesToolInputFunctionDeclarations;
  /** Optional. Retrieval tool type. System will always execute the provided retrieval tool(s) to get external knowledge to answer the prompt. Retrieval results are presented to the model for generation. */
  retrieval?: GoogleGenaiTypesToolInputRetrieval;
  /** Optional. Google Search tool type. Specialized retrieval tool
      that is powered by Google Search. */
  googleSearch?: GoogleGenaiTypesToolInputGoogleSearch;
  /** Optional. GoogleSearchRetrieval tool type. Specialized retrieval tool that is powered by Google search. */
  googleSearchRetrieval?: GoogleGenaiTypesToolInputGoogleSearchRetrieval;
  /** Optional. Enterprise web search tool type. Specialized retrieval
      tool that is powered by Vertex AI Search and Sec4 compliance. */
  enterpriseWebSearch?: GoogleGenaiTypesToolInputEnterpriseWebSearch;
  /** Optional. Google Maps tool type. Specialized retrieval tool
      that is powered by Google Maps. */
  googleMaps?: GoogleGenaiTypesToolInputGoogleMaps;
  /** Optional. Tool to support URL context retrieval. */
  urlContext?: GoogleGenaiTypesToolInputUrlContext;
  /** Optional. Tool to support the model interacting directly with the
      computer. If enabled, it automatically populates computer-use specific
      Function Declarations. */
  computerUse?: GoogleGenaiTypesToolInputComputerUse;
  /** Optional. CodeExecution tool type. Enables the model to execute code as part of generation. */
  codeExecution?: GoogleGenaiTypesToolInputCodeExecution;
}

/**
 * List of function declarations that the tool supports.
 */
export type GoogleGenaiTypesToolOutputFunctionDeclarations =
  | FunctionDeclarationOutput[]
  | null;

/**
 * Optional. Retrieval tool type. System will always execute the provided retrieval tool(s) to get external knowledge to answer the prompt. Retrieval results are presented to the model for generation.
 */
export type GoogleGenaiTypesToolOutputRetrieval = RetrievalOutput | null;

/**
 * Optional. Google Search tool type. Specialized retrieval tool
      that is powered by Google Search.
 */
export type GoogleGenaiTypesToolOutputGoogleSearch = GoogleSearchOutput | null;

/**
 * Optional. GoogleSearchRetrieval tool type. Specialized retrieval tool that is powered by Google search.
 */
export type GoogleGenaiTypesToolOutputGoogleSearchRetrieval =
  GoogleSearchRetrievalOutput | null;

/**
 * Optional. Enterprise web search tool type. Specialized retrieval
      tool that is powered by Vertex AI Search and Sec4 compliance.
 */
export type GoogleGenaiTypesToolOutputEnterpriseWebSearch =
  EnterpriseWebSearch | null;

/**
 * Optional. Google Maps tool type. Specialized retrieval tool
      that is powered by Google Maps.
 */
export type GoogleGenaiTypesToolOutputGoogleMaps = GoogleMapsOutput | null;

/**
 * Optional. Tool to support URL context retrieval.
 */
export type GoogleGenaiTypesToolOutputUrlContext = UrlContext | null;

/**
 * Optional. Tool to support the model interacting directly with the
      computer. If enabled, it automatically populates computer-use specific
      Function Declarations.
 */
export type GoogleGenaiTypesToolOutputComputerUse = ToolComputerUse | null;

/**
 * Optional. CodeExecution tool type. Enables the model to execute code as part of generation.
 */
export type GoogleGenaiTypesToolOutputCodeExecution = ToolCodeExecution | null;

/**
 * Tool details of a tool that the model may use to generate a response.
 */
export interface GoogleGenaiTypesToolOutput {
  /** List of function declarations that the tool supports. */
  functionDeclarations?: GoogleGenaiTypesToolOutputFunctionDeclarations;
  /** Optional. Retrieval tool type. System will always execute the provided retrieval tool(s) to get external knowledge to answer the prompt. Retrieval results are presented to the model for generation. */
  retrieval?: GoogleGenaiTypesToolOutputRetrieval;
  /** Optional. Google Search tool type. Specialized retrieval tool
      that is powered by Google Search. */
  googleSearch?: GoogleGenaiTypesToolOutputGoogleSearch;
  /** Optional. GoogleSearchRetrieval tool type. Specialized retrieval tool that is powered by Google search. */
  googleSearchRetrieval?: GoogleGenaiTypesToolOutputGoogleSearchRetrieval;
  /** Optional. Enterprise web search tool type. Specialized retrieval
      tool that is powered by Vertex AI Search and Sec4 compliance. */
  enterpriseWebSearch?: GoogleGenaiTypesToolOutputEnterpriseWebSearch;
  /** Optional. Google Maps tool type. Specialized retrieval tool
      that is powered by Google Maps. */
  googleMaps?: GoogleGenaiTypesToolOutputGoogleMaps;
  /** Optional. Tool to support URL context retrieval. */
  urlContext?: GoogleGenaiTypesToolOutputUrlContext;
  /** Optional. Tool to support the model interacting directly with the
      computer. If enabled, it automatically populates computer-use specific
      Function Declarations. */
  computerUse?: GoogleGenaiTypesToolOutputComputerUse;
  /** Optional. CodeExecution tool type. Enables the model to execute code as part of generation. */
  codeExecution?: GoogleGenaiTypesToolOutputCodeExecution;
}

export type McpTypesToolTitle = string | null;

export type McpTypesToolDescription = string | null;

export type McpTypesToolInputSchema = { [key: string]: unknown };

export type McpTypesToolOutputSchemaAnyOf = { [key: string]: unknown };

export type McpTypesToolOutputSchema = McpTypesToolOutputSchemaAnyOf | null;

export type McpTypesToolAnnotations = ToolAnnotations | null;

export type _McpTypesToolMetaAnyOf = { [key: string]: unknown };

export type _McpTypesToolMeta = _McpTypesToolMetaAnyOf | null;

/**
 * Definition for a tool the client can call.
 */
export interface McpTypesTool {
  name: string;
  title?: McpTypesToolTitle;
  description?: McpTypesToolDescription;
  inputSchema: McpTypesToolInputSchema;
  outputSchema?: McpTypesToolOutputSchema;
  annotations?: McpTypesToolAnnotations;
  _meta?: _McpTypesToolMeta;
  [key: string]: unknown;
}

export type CreateSessionWithIdAppsAppNameUsersUserIdSessionsSessionIdPostBodyAnyOf =
  { [key: string]: unknown };

export type CreateSessionWithIdAppsAppNameUsersUserIdSessionsSessionIdPostBody =
  CreateSessionWithIdAppsAppNameUsersUserIdSessionsSessionIdPostBodyAnyOf | null;

export type LoadArtifactAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameGetParams =
  {
    version?: number | null;
  };

export type LoadArtifactAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameGet200 =
  PartOutput | null;

export type LoadArtifactVersionAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameVersionsVersionIdGet200 =
  PartOutput | null;

/**
 * @summary List Apps
 */
export const listAppsListAppsGet = (signal?: AbortSignal) => {
  return customInstance<string[]>({
    url: `http://localhost:8000/list-apps`,
    method: "GET",
    signal,
  });
};

export const getListAppsListAppsGetQueryKey = () => {
  return [`http://localhost:8000/list-apps`] as const;
};

export const getListAppsListAppsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof listAppsListAppsGet>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof listAppsListAppsGet>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListAppsListAppsGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listAppsListAppsGet>>
  > = ({ signal }) => listAppsListAppsGet(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listAppsListAppsGet>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ListAppsListAppsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof listAppsListAppsGet>>
>;
export type ListAppsListAppsGetQueryError = unknown;

/**
 * @summary List Apps
 */

export function useListAppsListAppsGet<
  TData = Awaited<ReturnType<typeof listAppsListAppsGet>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof listAppsListAppsGet>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getListAppsListAppsGetQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get Trace Dict
 */
export const getTraceDictDebugTraceEventIdGet = (
  eventId: string,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>({
    url: `http://localhost:8000/debug/trace/${eventId}`,
    method: "GET",
    signal,
  });
};

export const getGetTraceDictDebugTraceEventIdGetQueryKey = (
  eventId?: string,
) => {
  return [`http://localhost:8000/debug/trace/${eventId}`] as const;
};

export const getGetTraceDictDebugTraceEventIdGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getTraceDictDebugTraceEventIdGet>>,
  TError = HTTPValidationError,
>(
  eventId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getTraceDictDebugTraceEventIdGet>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetTraceDictDebugTraceEventIdGetQueryKey(eventId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTraceDictDebugTraceEventIdGet>>
  > = ({ signal }) => getTraceDictDebugTraceEventIdGet(eventId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!eventId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getTraceDictDebugTraceEventIdGet>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetTraceDictDebugTraceEventIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTraceDictDebugTraceEventIdGet>>
>;
export type GetTraceDictDebugTraceEventIdGetQueryError = HTTPValidationError;

/**
 * @summary Get Trace Dict
 */

export function useGetTraceDictDebugTraceEventIdGet<
  TData = Awaited<ReturnType<typeof getTraceDictDebugTraceEventIdGet>>,
  TError = HTTPValidationError,
>(
  eventId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getTraceDictDebugTraceEventIdGet>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetTraceDictDebugTraceEventIdGetQueryOptions(
    eventId,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get Session Trace
 */
export const getSessionTraceDebugTraceSessionSessionIdGet = (
  sessionId: string,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>({
    url: `http://localhost:8000/debug/trace/session/${sessionId}`,
    method: "GET",
    signal,
  });
};

export const getGetSessionTraceDebugTraceSessionSessionIdGetQueryKey = (
  sessionId?: string,
) => {
  return [`http://localhost:8000/debug/trace/session/${sessionId}`] as const;
};

export const getGetSessionTraceDebugTraceSessionSessionIdGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getSessionTraceDebugTraceSessionSessionIdGet>
  >,
  TError = HTTPValidationError,
>(
  sessionId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getSessionTraceDebugTraceSessionSessionIdGet>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetSessionTraceDebugTraceSessionSessionIdGetQueryKey(sessionId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSessionTraceDebugTraceSessionSessionIdGet>>
  > = ({ signal }) =>
    getSessionTraceDebugTraceSessionSessionIdGet(sessionId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!sessionId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getSessionTraceDebugTraceSessionSessionIdGet>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetSessionTraceDebugTraceSessionSessionIdGetQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof getSessionTraceDebugTraceSessionSessionIdGet>>
  >;
export type GetSessionTraceDebugTraceSessionSessionIdGetQueryError =
  HTTPValidationError;

/**
 * @summary Get Session Trace
 */

export function useGetSessionTraceDebugTraceSessionSessionIdGet<
  TData = Awaited<
    ReturnType<typeof getSessionTraceDebugTraceSessionSessionIdGet>
  >,
  TError = HTTPValidationError,
>(
  sessionId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getSessionTraceDebugTraceSessionSessionIdGet>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions =
    getGetSessionTraceDebugTraceSessionSessionIdGetQueryOptions(
      sessionId,
      options,
    );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get Session
 */
export const getSessionAppsAppNameUsersUserIdSessionsSessionIdGet = (
  appName: string,
  userId: string,
  sessionId: string,
  signal?: AbortSignal,
) => {
  return customInstance<Session>({
    url: `http://localhost:8000/apps/${appName}/users/${userId}/sessions/${sessionId}`,
    method: "GET",
    signal,
  });
};

export const getGetSessionAppsAppNameUsersUserIdSessionsSessionIdGetQueryKey = (
  appName?: string,
  userId?: string,
  sessionId?: string,
) => {
  return [
    `http://localhost:8000/apps/${appName}/users/${userId}/sessions/${sessionId}`,
  ] as const;
};

export const getGetSessionAppsAppNameUsersUserIdSessionsSessionIdGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<typeof getSessionAppsAppNameUsersUserIdSessionsSessionIdGet>
    >,
    TError = HTTPValidationError,
  >(
    appName: string,
    userId: string,
    sessionId: string,
    options?: {
      query?: UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getSessionAppsAppNameUsersUserIdSessionsSessionIdGet
          >
        >,
        TError,
        TData
      >;
    },
  ) => {
    const { query: queryOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getGetSessionAppsAppNameUsersUserIdSessionsSessionIdGetQueryKey(
        appName,
        userId,
        sessionId,
      );

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<typeof getSessionAppsAppNameUsersUserIdSessionsSessionIdGet>
      >
    > = ({ signal }) =>
      getSessionAppsAppNameUsersUserIdSessionsSessionIdGet(
        appName,
        userId,
        sessionId,
        signal,
      );

    return {
      queryKey,
      queryFn,
      enabled: !!(appName && userId && sessionId),
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<typeof getSessionAppsAppNameUsersUserIdSessionsSessionIdGet>
      >,
      TError,
      TData
    > & { queryKey: QueryKey };
  };

export type GetSessionAppsAppNameUsersUserIdSessionsSessionIdGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<typeof getSessionAppsAppNameUsersUserIdSessionsSessionIdGet>
    >
  >;
export type GetSessionAppsAppNameUsersUserIdSessionsSessionIdGetQueryError =
  HTTPValidationError;

/**
 * @summary Get Session
 */

export function useGetSessionAppsAppNameUsersUserIdSessionsSessionIdGet<
  TData = Awaited<
    ReturnType<typeof getSessionAppsAppNameUsersUserIdSessionsSessionIdGet>
  >,
  TError = HTTPValidationError,
>(
  appName: string,
  userId: string,
  sessionId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<
        ReturnType<typeof getSessionAppsAppNameUsersUserIdSessionsSessionIdGet>
      >,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions =
    getGetSessionAppsAppNameUsersUserIdSessionsSessionIdGetQueryOptions(
      appName,
      userId,
      sessionId,
      options,
    );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Create Session With Id
 */
export const createSessionWithIdAppsAppNameUsersUserIdSessionsSessionIdPost = (
  appName: string,
  userId: string,
  sessionId: string,
  createSessionWithIdAppsAppNameUsersUserIdSessionsSessionIdPostBody: CreateSessionWithIdAppsAppNameUsersUserIdSessionsSessionIdPostBody,
  signal?: AbortSignal,
) => {
  return customInstance<Session>({
    url: `http://localhost:8000/apps/${appName}/users/${userId}/sessions/${sessionId}`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: createSessionWithIdAppsAppNameUsersUserIdSessionsSessionIdPostBody,
    signal,
  });
};

export const getCreateSessionWithIdAppsAppNameUsersUserIdSessionsSessionIdPostMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof createSessionWithIdAppsAppNameUsersUserIdSessionsSessionIdPost
        >
      >,
      TError,
      {
        appName: string;
        userId: string;
        sessionId: string;
        data: CreateSessionWithIdAppsAppNameUsersUserIdSessionsSessionIdPostBody;
      },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<
        typeof createSessionWithIdAppsAppNameUsersUserIdSessionsSessionIdPost
      >
    >,
    TError,
    {
      appName: string;
      userId: string;
      sessionId: string;
      data: CreateSessionWithIdAppsAppNameUsersUserIdSessionsSessionIdPostBody;
    },
    TContext
  > => {
    const mutationKey = [
      "createSessionWithIdAppsAppNameUsersUserIdSessionsSessionIdPost",
    ];
    const { mutation: mutationOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<
          typeof createSessionWithIdAppsAppNameUsersUserIdSessionsSessionIdPost
        >
      >,
      {
        appName: string;
        userId: string;
        sessionId: string;
        data: CreateSessionWithIdAppsAppNameUsersUserIdSessionsSessionIdPostBody;
      }
    > = (props) => {
      const { appName, userId, sessionId, data } = props ?? {};

      return createSessionWithIdAppsAppNameUsersUserIdSessionsSessionIdPost(
        appName,
        userId,
        sessionId,
        data,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type CreateSessionWithIdAppsAppNameUsersUserIdSessionsSessionIdPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof createSessionWithIdAppsAppNameUsersUserIdSessionsSessionIdPost
      >
    >
  >;
export type CreateSessionWithIdAppsAppNameUsersUserIdSessionsSessionIdPostMutationBody =
  CreateSessionWithIdAppsAppNameUsersUserIdSessionsSessionIdPostBody;
export type CreateSessionWithIdAppsAppNameUsersUserIdSessionsSessionIdPostMutationError =
  HTTPValidationError;

/**
 * @summary Create Session With Id
 */
export const useCreateSessionWithIdAppsAppNameUsersUserIdSessionsSessionIdPost =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof createSessionWithIdAppsAppNameUsersUserIdSessionsSessionIdPost
        >
      >,
      TError,
      {
        appName: string;
        userId: string;
        sessionId: string;
        data: CreateSessionWithIdAppsAppNameUsersUserIdSessionsSessionIdPostBody;
      },
      TContext
    >;
  }): UseMutationResult<
    Awaited<
      ReturnType<
        typeof createSessionWithIdAppsAppNameUsersUserIdSessionsSessionIdPost
      >
    >,
    TError,
    {
      appName: string;
      userId: string;
      sessionId: string;
      data: CreateSessionWithIdAppsAppNameUsersUserIdSessionsSessionIdPostBody;
    },
    TContext
  > => {
    const mutationOptions =
      getCreateSessionWithIdAppsAppNameUsersUserIdSessionsSessionIdPostMutationOptions(
        options,
      );

    return useMutation(mutationOptions);
  };

/**
 * @summary Delete Session
 */
export const deleteSessionAppsAppNameUsersUserIdSessionsSessionIdDelete = (
  appName: string,
  userId: string,
  sessionId: string,
) => {
  return customInstance<null>({
    url: `http://localhost:8000/apps/${appName}/users/${userId}/sessions/${sessionId}`,
    method: "DELETE",
  });
};

export const getDeleteSessionAppsAppNameUsersUserIdSessionsSessionIdDeleteMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof deleteSessionAppsAppNameUsersUserIdSessionsSessionIdDelete
        >
      >,
      TError,
      { appName: string; userId: string; sessionId: string },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<
        typeof deleteSessionAppsAppNameUsersUserIdSessionsSessionIdDelete
      >
    >,
    TError,
    { appName: string; userId: string; sessionId: string },
    TContext
  > => {
    const mutationKey = [
      "deleteSessionAppsAppNameUsersUserIdSessionsSessionIdDelete",
    ];
    const { mutation: mutationOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<
          typeof deleteSessionAppsAppNameUsersUserIdSessionsSessionIdDelete
        >
      >,
      { appName: string; userId: string; sessionId: string }
    > = (props) => {
      const { appName, userId, sessionId } = props ?? {};

      return deleteSessionAppsAppNameUsersUserIdSessionsSessionIdDelete(
        appName,
        userId,
        sessionId,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type DeleteSessionAppsAppNameUsersUserIdSessionsSessionIdDeleteMutationResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof deleteSessionAppsAppNameUsersUserIdSessionsSessionIdDelete
      >
    >
  >;

export type DeleteSessionAppsAppNameUsersUserIdSessionsSessionIdDeleteMutationError =
  HTTPValidationError;

/**
 * @summary Delete Session
 */
export const useDeleteSessionAppsAppNameUsersUserIdSessionsSessionIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<
      ReturnType<
        typeof deleteSessionAppsAppNameUsersUserIdSessionsSessionIdDelete
      >
    >,
    TError,
    { appName: string; userId: string; sessionId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<
    ReturnType<
      typeof deleteSessionAppsAppNameUsersUserIdSessionsSessionIdDelete
    >
  >,
  TError,
  { appName: string; userId: string; sessionId: string },
  TContext
> => {
  const mutationOptions =
    getDeleteSessionAppsAppNameUsersUserIdSessionsSessionIdDeleteMutationOptions(
      options,
    );

  return useMutation(mutationOptions);
};

/**
 * @summary List Sessions
 */
export const listSessionsAppsAppNameUsersUserIdSessionsGet = (
  appName: string,
  userId: string,
  signal?: AbortSignal,
) => {
  return customInstance<Session[]>({
    url: `http://localhost:8000/apps/${appName}/users/${userId}/sessions`,
    method: "GET",
    signal,
  });
};

export const getListSessionsAppsAppNameUsersUserIdSessionsGetQueryKey = (
  appName?: string,
  userId?: string,
) => {
  return [
    `http://localhost:8000/apps/${appName}/users/${userId}/sessions`,
  ] as const;
};

export const getListSessionsAppsAppNameUsersUserIdSessionsGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof listSessionsAppsAppNameUsersUserIdSessionsGet>
  >,
  TError = HTTPValidationError,
>(
  appName: string,
  userId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof listSessionsAppsAppNameUsersUserIdSessionsGet>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getListSessionsAppsAppNameUsersUserIdSessionsGetQueryKey(appName, userId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listSessionsAppsAppNameUsersUserIdSessionsGet>>
  > = ({ signal }) =>
    listSessionsAppsAppNameUsersUserIdSessionsGet(appName, userId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(appName && userId),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof listSessionsAppsAppNameUsersUserIdSessionsGet>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ListSessionsAppsAppNameUsersUserIdSessionsGetQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof listSessionsAppsAppNameUsersUserIdSessionsGet>>
  >;
export type ListSessionsAppsAppNameUsersUserIdSessionsGetQueryError =
  HTTPValidationError;

/**
 * @summary List Sessions
 */

export function useListSessionsAppsAppNameUsersUserIdSessionsGet<
  TData = Awaited<
    ReturnType<typeof listSessionsAppsAppNameUsersUserIdSessionsGet>
  >,
  TError = HTTPValidationError,
>(
  appName: string,
  userId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof listSessionsAppsAppNameUsersUserIdSessionsGet>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions =
    getListSessionsAppsAppNameUsersUserIdSessionsGetQueryOptions(
      appName,
      userId,
      options,
    );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Create Session
 */
export const createSessionAppsAppNameUsersUserIdSessionsPost = (
  appName: string,
  userId: string,
  bodyCreateSessionAppsAppNameUsersUserIdSessionsPost: BodyCreateSessionAppsAppNameUsersUserIdSessionsPost,
  signal?: AbortSignal,
) => {
  return customInstance<Session>({
    url: `http://localhost:8000/apps/${appName}/users/${userId}/sessions`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: bodyCreateSessionAppsAppNameUsersUserIdSessionsPost,
    signal,
  });
};

export const getCreateSessionAppsAppNameUsersUserIdSessionsPostMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof createSessionAppsAppNameUsersUserIdSessionsPost>
      >,
      TError,
      {
        appName: string;
        userId: string;
        data: BodyCreateSessionAppsAppNameUsersUserIdSessionsPost;
      },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<ReturnType<typeof createSessionAppsAppNameUsersUserIdSessionsPost>>,
    TError,
    {
      appName: string;
      userId: string;
      data: BodyCreateSessionAppsAppNameUsersUserIdSessionsPost;
    },
    TContext
  > => {
    const mutationKey = ["createSessionAppsAppNameUsersUserIdSessionsPost"];
    const { mutation: mutationOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof createSessionAppsAppNameUsersUserIdSessionsPost>
      >,
      {
        appName: string;
        userId: string;
        data: BodyCreateSessionAppsAppNameUsersUserIdSessionsPost;
      }
    > = (props) => {
      const { appName, userId, data } = props ?? {};

      return createSessionAppsAppNameUsersUserIdSessionsPost(
        appName,
        userId,
        data,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type CreateSessionAppsAppNameUsersUserIdSessionsPostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof createSessionAppsAppNameUsersUserIdSessionsPost>>
  >;
export type CreateSessionAppsAppNameUsersUserIdSessionsPostMutationBody =
  BodyCreateSessionAppsAppNameUsersUserIdSessionsPost;
export type CreateSessionAppsAppNameUsersUserIdSessionsPostMutationError =
  HTTPValidationError;

/**
 * @summary Create Session
 */
export const useCreateSessionAppsAppNameUsersUserIdSessionsPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createSessionAppsAppNameUsersUserIdSessionsPost>>,
    TError,
    {
      appName: string;
      userId: string;
      data: BodyCreateSessionAppsAppNameUsersUserIdSessionsPost;
    },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof createSessionAppsAppNameUsersUserIdSessionsPost>>,
  TError,
  {
    appName: string;
    userId: string;
    data: BodyCreateSessionAppsAppNameUsersUserIdSessionsPost;
  },
  TContext
> => {
  const mutationOptions =
    getCreateSessionAppsAppNameUsersUserIdSessionsPostMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Create Eval Set
 */
export const createEvalSetAppsAppNameEvalSetsPost = (
  appName: string,
  createEvalSetRequest: CreateEvalSetRequest,
  signal?: AbortSignal,
) => {
  return customInstance<EvalSetOutput>({
    url: `http://localhost:8000/apps/${appName}/eval-sets`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: createEvalSetRequest,
    signal,
  });
};

export const getCreateEvalSetAppsAppNameEvalSetsPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createEvalSetAppsAppNameEvalSetsPost>>,
    TError,
    { appName: string; data: CreateEvalSetRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createEvalSetAppsAppNameEvalSetsPost>>,
  TError,
  { appName: string; data: CreateEvalSetRequest },
  TContext
> => {
  const mutationKey = ["createEvalSetAppsAppNameEvalSetsPost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createEvalSetAppsAppNameEvalSetsPost>>,
    { appName: string; data: CreateEvalSetRequest }
  > = (props) => {
    const { appName, data } = props ?? {};

    return createEvalSetAppsAppNameEvalSetsPost(appName, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateEvalSetAppsAppNameEvalSetsPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createEvalSetAppsAppNameEvalSetsPost>>
>;
export type CreateEvalSetAppsAppNameEvalSetsPostMutationBody =
  CreateEvalSetRequest;
export type CreateEvalSetAppsAppNameEvalSetsPostMutationError =
  HTTPValidationError;

/**
 * @summary Create Eval Set
 */
export const useCreateEvalSetAppsAppNameEvalSetsPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createEvalSetAppsAppNameEvalSetsPost>>,
    TError,
    { appName: string; data: CreateEvalSetRequest },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof createEvalSetAppsAppNameEvalSetsPost>>,
  TError,
  { appName: string; data: CreateEvalSetRequest },
  TContext
> => {
  const mutationOptions =
    getCreateEvalSetAppsAppNameEvalSetsPostMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Lists all eval sets for the given app.
 * @summary List Eval Sets
 */
export const listEvalSetsAppsAppNameEvalSetsGet = (
  appName: string,
  signal?: AbortSignal,
) => {
  return customInstance<ListEvalSetsResponse>({
    url: `http://localhost:8000/apps/${appName}/eval-sets`,
    method: "GET",
    signal,
  });
};

export const getListEvalSetsAppsAppNameEvalSetsGetQueryKey = (
  appName?: string,
) => {
  return [`http://localhost:8000/apps/${appName}/eval-sets`] as const;
};

export const getListEvalSetsAppsAppNameEvalSetsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof listEvalSetsAppsAppNameEvalSetsGet>>,
  TError = HTTPValidationError,
>(
  appName: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof listEvalSetsAppsAppNameEvalSetsGet>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getListEvalSetsAppsAppNameEvalSetsGetQueryKey(appName);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listEvalSetsAppsAppNameEvalSetsGet>>
  > = ({ signal }) => listEvalSetsAppsAppNameEvalSetsGet(appName, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!appName,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof listEvalSetsAppsAppNameEvalSetsGet>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ListEvalSetsAppsAppNameEvalSetsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof listEvalSetsAppsAppNameEvalSetsGet>>
>;
export type ListEvalSetsAppsAppNameEvalSetsGetQueryError = HTTPValidationError;

/**
 * @summary List Eval Sets
 */

export function useListEvalSetsAppsAppNameEvalSetsGet<
  TData = Awaited<ReturnType<typeof listEvalSetsAppsAppNameEvalSetsGet>>,
  TError = HTTPValidationError,
>(
  appName: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof listEvalSetsAppsAppNameEvalSetsGet>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getListEvalSetsAppsAppNameEvalSetsGetQueryOptions(
    appName,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Creates an eval set, given the id.
 * @summary Create Eval Set Legacy
 */
export const createEvalSetLegacyAppsAppNameEvalSetsEvalSetIdPost = (
  appName: string,
  evalSetId: string,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>({
    url: `http://localhost:8000/apps/${appName}/eval_sets/${evalSetId}`,
    method: "POST",
    signal,
  });
};

export const getCreateEvalSetLegacyAppsAppNameEvalSetsEvalSetIdPostMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof createEvalSetLegacyAppsAppNameEvalSetsEvalSetIdPost>
      >,
      TError,
      { appName: string; evalSetId: string },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof createEvalSetLegacyAppsAppNameEvalSetsEvalSetIdPost>
    >,
    TError,
    { appName: string; evalSetId: string },
    TContext
  > => {
    const mutationKey = ["createEvalSetLegacyAppsAppNameEvalSetsEvalSetIdPost"];
    const { mutation: mutationOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof createEvalSetLegacyAppsAppNameEvalSetsEvalSetIdPost>
      >,
      { appName: string; evalSetId: string }
    > = (props) => {
      const { appName, evalSetId } = props ?? {};

      return createEvalSetLegacyAppsAppNameEvalSetsEvalSetIdPost(
        appName,
        evalSetId,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type CreateEvalSetLegacyAppsAppNameEvalSetsEvalSetIdPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof createEvalSetLegacyAppsAppNameEvalSetsEvalSetIdPost>
    >
  >;

export type CreateEvalSetLegacyAppsAppNameEvalSetsEvalSetIdPostMutationError =
  HTTPValidationError;

/**
 * @summary Create Eval Set Legacy
 */
export const useCreateEvalSetLegacyAppsAppNameEvalSetsEvalSetIdPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<
      ReturnType<typeof createEvalSetLegacyAppsAppNameEvalSetsEvalSetIdPost>
    >,
    TError,
    { appName: string; evalSetId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<
    ReturnType<typeof createEvalSetLegacyAppsAppNameEvalSetsEvalSetIdPost>
  >,
  TError,
  { appName: string; evalSetId: string },
  TContext
> => {
  const mutationOptions =
    getCreateEvalSetLegacyAppsAppNameEvalSetsEvalSetIdPostMutationOptions(
      options,
    );

  return useMutation(mutationOptions);
};

/**
 * @summary List Eval Sets Legacy
 */
export const listEvalSetsLegacyAppsAppNameEvalSetsGet = (
  appName: string,
  signal?: AbortSignal,
) => {
  return customInstance<string[]>({
    url: `http://localhost:8000/apps/${appName}/eval_sets`,
    method: "GET",
    signal,
  });
};

export const getListEvalSetsLegacyAppsAppNameEvalSetsGetQueryKey = (
  appName?: string,
) => {
  return [`http://localhost:8000/apps/${appName}/eval_sets`] as const;
};

export const getListEvalSetsLegacyAppsAppNameEvalSetsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof listEvalSetsLegacyAppsAppNameEvalSetsGet>>,
  TError = HTTPValidationError,
>(
  appName: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof listEvalSetsLegacyAppsAppNameEvalSetsGet>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getListEvalSetsLegacyAppsAppNameEvalSetsGetQueryKey(appName);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listEvalSetsLegacyAppsAppNameEvalSetsGet>>
  > = ({ signal }) => listEvalSetsLegacyAppsAppNameEvalSetsGet(appName, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!appName,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof listEvalSetsLegacyAppsAppNameEvalSetsGet>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ListEvalSetsLegacyAppsAppNameEvalSetsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof listEvalSetsLegacyAppsAppNameEvalSetsGet>>
>;
export type ListEvalSetsLegacyAppsAppNameEvalSetsGetQueryError =
  HTTPValidationError;

/**
 * @summary List Eval Sets Legacy
 */

export function useListEvalSetsLegacyAppsAppNameEvalSetsGet<
  TData = Awaited<ReturnType<typeof listEvalSetsLegacyAppsAppNameEvalSetsGet>>,
  TError = HTTPValidationError,
>(
  appName: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof listEvalSetsLegacyAppsAppNameEvalSetsGet>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getListEvalSetsLegacyAppsAppNameEvalSetsGetQueryOptions(
    appName,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Add Session To Eval Set
 */
export const addSessionToEvalSetAppsAppNameEvalSetsEvalSetIdAddSessionPost = (
  appName: string,
  evalSetId: string,
  addSessionToEvalSetRequest: AddSessionToEvalSetRequest,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>({
    url: `http://localhost:8000/apps/${appName}/eval-sets/${evalSetId}/add-session`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: addSessionToEvalSetRequest,
    signal,
  });
};

export const getAddSessionToEvalSetAppsAppNameEvalSetsEvalSetIdAddSessionPostMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof addSessionToEvalSetAppsAppNameEvalSetsEvalSetIdAddSessionPost
        >
      >,
      TError,
      { appName: string; evalSetId: string; data: AddSessionToEvalSetRequest },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<
        typeof addSessionToEvalSetAppsAppNameEvalSetsEvalSetIdAddSessionPost
      >
    >,
    TError,
    { appName: string; evalSetId: string; data: AddSessionToEvalSetRequest },
    TContext
  > => {
    const mutationKey = [
      "addSessionToEvalSetAppsAppNameEvalSetsEvalSetIdAddSessionPost",
    ];
    const { mutation: mutationOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<
          typeof addSessionToEvalSetAppsAppNameEvalSetsEvalSetIdAddSessionPost
        >
      >,
      { appName: string; evalSetId: string; data: AddSessionToEvalSetRequest }
    > = (props) => {
      const { appName, evalSetId, data } = props ?? {};

      return addSessionToEvalSetAppsAppNameEvalSetsEvalSetIdAddSessionPost(
        appName,
        evalSetId,
        data,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type AddSessionToEvalSetAppsAppNameEvalSetsEvalSetIdAddSessionPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof addSessionToEvalSetAppsAppNameEvalSetsEvalSetIdAddSessionPost
      >
    >
  >;
export type AddSessionToEvalSetAppsAppNameEvalSetsEvalSetIdAddSessionPostMutationBody =
  AddSessionToEvalSetRequest;
export type AddSessionToEvalSetAppsAppNameEvalSetsEvalSetIdAddSessionPostMutationError =
  HTTPValidationError;

/**
 * @summary Add Session To Eval Set
 */
export const useAddSessionToEvalSetAppsAppNameEvalSetsEvalSetIdAddSessionPost =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof addSessionToEvalSetAppsAppNameEvalSetsEvalSetIdAddSessionPost
        >
      >,
      TError,
      { appName: string; evalSetId: string; data: AddSessionToEvalSetRequest },
      TContext
    >;
  }): UseMutationResult<
    Awaited<
      ReturnType<
        typeof addSessionToEvalSetAppsAppNameEvalSetsEvalSetIdAddSessionPost
      >
    >,
    TError,
    { appName: string; evalSetId: string; data: AddSessionToEvalSetRequest },
    TContext
  > => {
    const mutationOptions =
      getAddSessionToEvalSetAppsAppNameEvalSetsEvalSetIdAddSessionPostMutationOptions(
        options,
      );

    return useMutation(mutationOptions);
  };

/**
 * Lists all evals in an eval set.
 * @summary List Evals In Eval Set
 */
export const listEvalsInEvalSetAppsAppNameEvalSetsEvalSetIdEvalsGet = (
  appName: string,
  evalSetId: string,
  signal?: AbortSignal,
) => {
  return customInstance<string[]>({
    url: `http://localhost:8000/apps/${appName}/eval_sets/${evalSetId}/evals`,
    method: "GET",
    signal,
  });
};

export const getListEvalsInEvalSetAppsAppNameEvalSetsEvalSetIdEvalsGetQueryKey =
  (appName?: string, evalSetId?: string) => {
    return [
      `http://localhost:8000/apps/${appName}/eval_sets/${evalSetId}/evals`,
    ] as const;
  };

export const getListEvalsInEvalSetAppsAppNameEvalSetsEvalSetIdEvalsGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<typeof listEvalsInEvalSetAppsAppNameEvalSetsEvalSetIdEvalsGet>
    >,
    TError = HTTPValidationError,
  >(
    appName: string,
    evalSetId: string,
    options?: {
      query?: UseQueryOptions<
        Awaited<
          ReturnType<
            typeof listEvalsInEvalSetAppsAppNameEvalSetsEvalSetIdEvalsGet
          >
        >,
        TError,
        TData
      >;
    },
  ) => {
    const { query: queryOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getListEvalsInEvalSetAppsAppNameEvalSetsEvalSetIdEvalsGetQueryKey(
        appName,
        evalSetId,
      );

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<
          typeof listEvalsInEvalSetAppsAppNameEvalSetsEvalSetIdEvalsGet
        >
      >
    > = ({ signal }) =>
      listEvalsInEvalSetAppsAppNameEvalSetsEvalSetIdEvalsGet(
        appName,
        evalSetId,
        signal,
      );

    return {
      queryKey,
      queryFn,
      enabled: !!(appName && evalSetId),
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<
          typeof listEvalsInEvalSetAppsAppNameEvalSetsEvalSetIdEvalsGet
        >
      >,
      TError,
      TData
    > & { queryKey: QueryKey };
  };

export type ListEvalsInEvalSetAppsAppNameEvalSetsEvalSetIdEvalsGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<typeof listEvalsInEvalSetAppsAppNameEvalSetsEvalSetIdEvalsGet>
    >
  >;
export type ListEvalsInEvalSetAppsAppNameEvalSetsEvalSetIdEvalsGetQueryError =
  HTTPValidationError;

/**
 * @summary List Evals In Eval Set
 */

export function useListEvalsInEvalSetAppsAppNameEvalSetsEvalSetIdEvalsGet<
  TData = Awaited<
    ReturnType<typeof listEvalsInEvalSetAppsAppNameEvalSetsEvalSetIdEvalsGet>
  >,
  TError = HTTPValidationError,
>(
  appName: string,
  evalSetId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<
        ReturnType<
          typeof listEvalsInEvalSetAppsAppNameEvalSetsEvalSetIdEvalsGet
        >
      >,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions =
    getListEvalsInEvalSetAppsAppNameEvalSetsEvalSetIdEvalsGetQueryOptions(
      appName,
      evalSetId,
      options,
    );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Gets an eval case in an eval set.
 * @summary Get Eval
 */
export const getEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdGet = (
  appName: string,
  evalSetId: string,
  evalCaseId: string,
  signal?: AbortSignal,
) => {
  return customInstance<EvalCaseOutput>({
    url: `http://localhost:8000/apps/${appName}/eval_sets/${evalSetId}/evals/${evalCaseId}`,
    method: "GET",
    signal,
  });
};

export const getGetEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdGetQueryKey =
  (appName?: string, evalSetId?: string, evalCaseId?: string) => {
    return [
      `http://localhost:8000/apps/${appName}/eval_sets/${evalSetId}/evals/${evalCaseId}`,
    ] as const;
  };

export const getGetEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<typeof getEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdGet>
    >,
    TError = HTTPValidationError,
  >(
    appName: string,
    evalSetId: string,
    evalCaseId: string,
    options?: {
      query?: UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdGet
          >
        >,
        TError,
        TData
      >;
    },
  ) => {
    const { query: queryOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getGetEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdGetQueryKey(
        appName,
        evalSetId,
        evalCaseId,
      );

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<typeof getEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdGet>
      >
    > = ({ signal }) =>
      getEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdGet(
        appName,
        evalSetId,
        evalCaseId,
        signal,
      );

    return {
      queryKey,
      queryFn,
      enabled: !!(appName && evalSetId && evalCaseId),
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<typeof getEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdGet>
      >,
      TError,
      TData
    > & { queryKey: QueryKey };
  };

export type GetEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<typeof getEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdGet>
    >
  >;
export type GetEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdGetQueryError =
  HTTPValidationError;

/**
 * @summary Get Eval
 */

export function useGetEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdGet<
  TData = Awaited<
    ReturnType<typeof getEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdGet>
  >,
  TError = HTTPValidationError,
>(
  appName: string,
  evalSetId: string,
  evalCaseId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<
        ReturnType<typeof getEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdGet>
      >,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions =
    getGetEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdGetQueryOptions(
      appName,
      evalSetId,
      evalCaseId,
      options,
    );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Update Eval
 */
export const updateEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdPut = (
  appName: string,
  evalSetId: string,
  evalCaseId: string,
  evalCaseInput: EvalCaseInput,
) => {
  return customInstance<unknown>({
    url: `http://localhost:8000/apps/${appName}/eval_sets/${evalSetId}/evals/${evalCaseId}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: evalCaseInput,
  });
};

export const getUpdateEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdPutMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof updateEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdPut
        >
      >,
      TError,
      {
        appName: string;
        evalSetId: string;
        evalCaseId: string;
        data: EvalCaseInput;
      },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<
        typeof updateEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdPut
      >
    >,
    TError,
    {
      appName: string;
      evalSetId: string;
      evalCaseId: string;
      data: EvalCaseInput;
    },
    TContext
  > => {
    const mutationKey = [
      "updateEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdPut",
    ];
    const { mutation: mutationOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<
          typeof updateEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdPut
        >
      >,
      {
        appName: string;
        evalSetId: string;
        evalCaseId: string;
        data: EvalCaseInput;
      }
    > = (props) => {
      const { appName, evalSetId, evalCaseId, data } = props ?? {};

      return updateEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdPut(
        appName,
        evalSetId,
        evalCaseId,
        data,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type UpdateEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdPutMutationResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof updateEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdPut
      >
    >
  >;
export type UpdateEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdPutMutationBody =
  EvalCaseInput;
export type UpdateEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdPutMutationError =
  HTTPValidationError;

/**
 * @summary Update Eval
 */
export const useUpdateEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdPut = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<
      ReturnType<
        typeof updateEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdPut
      >
    >,
    TError,
    {
      appName: string;
      evalSetId: string;
      evalCaseId: string;
      data: EvalCaseInput;
    },
    TContext
  >;
}): UseMutationResult<
  Awaited<
    ReturnType<typeof updateEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdPut>
  >,
  TError,
  {
    appName: string;
    evalSetId: string;
    evalCaseId: string;
    data: EvalCaseInput;
  },
  TContext
> => {
  const mutationOptions =
    getUpdateEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdPutMutationOptions(
      options,
    );

  return useMutation(mutationOptions);
};

/**
 * @summary Delete Eval
 */
export const deleteEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdDelete = (
  appName: string,
  evalSetId: string,
  evalCaseId: string,
) => {
  return customInstance<null>({
    url: `http://localhost:8000/apps/${appName}/eval_sets/${evalSetId}/evals/${evalCaseId}`,
    method: "DELETE",
  });
};

export const getDeleteEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdDeleteMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof deleteEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdDelete
        >
      >,
      TError,
      { appName: string; evalSetId: string; evalCaseId: string },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<
        typeof deleteEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdDelete
      >
    >,
    TError,
    { appName: string; evalSetId: string; evalCaseId: string },
    TContext
  > => {
    const mutationKey = [
      "deleteEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdDelete",
    ];
    const { mutation: mutationOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<
          typeof deleteEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdDelete
        >
      >,
      { appName: string; evalSetId: string; evalCaseId: string }
    > = (props) => {
      const { appName, evalSetId, evalCaseId } = props ?? {};

      return deleteEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdDelete(
        appName,
        evalSetId,
        evalCaseId,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type DeleteEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdDeleteMutationResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof deleteEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdDelete
      >
    >
  >;

export type DeleteEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdDeleteMutationError =
  HTTPValidationError;

/**
 * @summary Delete Eval
 */
export const useDeleteEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<
      ReturnType<
        typeof deleteEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdDelete
      >
    >,
    TError,
    { appName: string; evalSetId: string; evalCaseId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<
    ReturnType<
      typeof deleteEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdDelete
    >
  >,
  TError,
  { appName: string; evalSetId: string; evalCaseId: string },
  TContext
> => {
  const mutationOptions =
    getDeleteEvalAppsAppNameEvalSetsEvalSetIdEvalsEvalCaseIdDeleteMutationOptions(
      options,
    );

  return useMutation(mutationOptions);
};

/**
 * Gets an eval case in an eval set.
 * @summary Get Eval
 */
export const getEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdGet = (
  appName: string,
  evalSetId: string,
  evalCaseId: string,
  signal?: AbortSignal,
) => {
  return customInstance<EvalCaseOutput>({
    url: `http://localhost:8000/apps/${appName}/eval-sets/${evalSetId}/eval-cases/${evalCaseId}`,
    method: "GET",
    signal,
  });
};

export const getGetEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdGetQueryKey =
  (appName?: string, evalSetId?: string, evalCaseId?: string) => {
    return [
      `http://localhost:8000/apps/${appName}/eval-sets/${evalSetId}/eval-cases/${evalCaseId}`,
    ] as const;
  };

export const getGetEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<
        typeof getEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdGet
      >
    >,
    TError = HTTPValidationError,
  >(
    appName: string,
    evalSetId: string,
    evalCaseId: string,
    options?: {
      query?: UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdGet
          >
        >,
        TError,
        TData
      >;
    },
  ) => {
    const { query: queryOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getGetEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdGetQueryKey(
        appName,
        evalSetId,
        evalCaseId,
      );

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<
          typeof getEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdGet
        >
      >
    > = ({ signal }) =>
      getEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdGet(
        appName,
        evalSetId,
        evalCaseId,
        signal,
      );

    return {
      queryKey,
      queryFn,
      enabled: !!(appName && evalSetId && evalCaseId),
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<
          typeof getEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdGet
        >
      >,
      TError,
      TData
    > & { queryKey: QueryKey };
  };

export type GetEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof getEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdGet
      >
    >
  >;
export type GetEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdGetQueryError =
  HTTPValidationError;

/**
 * @summary Get Eval
 */

export function useGetEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdGet<
  TData = Awaited<
    ReturnType<typeof getEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdGet>
  >,
  TError = HTTPValidationError,
>(
  appName: string,
  evalSetId: string,
  evalCaseId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<
        ReturnType<
          typeof getEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdGet
        >
      >,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions =
    getGetEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdGetQueryOptions(
      appName,
      evalSetId,
      evalCaseId,
      options,
    );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Update Eval
 */
export const updateEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdPut = (
  appName: string,
  evalSetId: string,
  evalCaseId: string,
  evalCaseInput: EvalCaseInput,
) => {
  return customInstance<unknown>({
    url: `http://localhost:8000/apps/${appName}/eval-sets/${evalSetId}/eval-cases/${evalCaseId}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: evalCaseInput,
  });
};

export const getUpdateEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdPutMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof updateEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdPut
        >
      >,
      TError,
      {
        appName: string;
        evalSetId: string;
        evalCaseId: string;
        data: EvalCaseInput;
      },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<
        typeof updateEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdPut
      >
    >,
    TError,
    {
      appName: string;
      evalSetId: string;
      evalCaseId: string;
      data: EvalCaseInput;
    },
    TContext
  > => {
    const mutationKey = [
      "updateEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdPut",
    ];
    const { mutation: mutationOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<
          typeof updateEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdPut
        >
      >,
      {
        appName: string;
        evalSetId: string;
        evalCaseId: string;
        data: EvalCaseInput;
      }
    > = (props) => {
      const { appName, evalSetId, evalCaseId, data } = props ?? {};

      return updateEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdPut(
        appName,
        evalSetId,
        evalCaseId,
        data,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type UpdateEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdPutMutationResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof updateEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdPut
      >
    >
  >;
export type UpdateEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdPutMutationBody =
  EvalCaseInput;
export type UpdateEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdPutMutationError =
  HTTPValidationError;

/**
 * @summary Update Eval
 */
export const useUpdateEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdPut = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<
      ReturnType<
        typeof updateEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdPut
      >
    >,
    TError,
    {
      appName: string;
      evalSetId: string;
      evalCaseId: string;
      data: EvalCaseInput;
    },
    TContext
  >;
}): UseMutationResult<
  Awaited<
    ReturnType<
      typeof updateEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdPut
    >
  >,
  TError,
  {
    appName: string;
    evalSetId: string;
    evalCaseId: string;
    data: EvalCaseInput;
  },
  TContext
> => {
  const mutationOptions =
    getUpdateEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdPutMutationOptions(
      options,
    );

  return useMutation(mutationOptions);
};

/**
 * @summary Delete Eval
 */
export const deleteEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdDelete = (
  appName: string,
  evalSetId: string,
  evalCaseId: string,
) => {
  return customInstance<null>({
    url: `http://localhost:8000/apps/${appName}/eval-sets/${evalSetId}/eval-cases/${evalCaseId}`,
    method: "DELETE",
  });
};

export const getDeleteEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdDeleteMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof deleteEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdDelete
        >
      >,
      TError,
      { appName: string; evalSetId: string; evalCaseId: string },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<
        typeof deleteEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdDelete
      >
    >,
    TError,
    { appName: string; evalSetId: string; evalCaseId: string },
    TContext
  > => {
    const mutationKey = [
      "deleteEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdDelete",
    ];
    const { mutation: mutationOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<
          typeof deleteEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdDelete
        >
      >,
      { appName: string; evalSetId: string; evalCaseId: string }
    > = (props) => {
      const { appName, evalSetId, evalCaseId } = props ?? {};

      return deleteEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdDelete(
        appName,
        evalSetId,
        evalCaseId,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type DeleteEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdDeleteMutationResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof deleteEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdDelete
      >
    >
  >;

export type DeleteEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdDeleteMutationError =
  HTTPValidationError;

/**
 * @summary Delete Eval
 */
export const useDeleteEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdDelete =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof deleteEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdDelete
        >
      >,
      TError,
      { appName: string; evalSetId: string; evalCaseId: string },
      TContext
    >;
  }): UseMutationResult<
    Awaited<
      ReturnType<
        typeof deleteEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdDelete
      >
    >,
    TError,
    { appName: string; evalSetId: string; evalCaseId: string },
    TContext
  > => {
    const mutationOptions =
      getDeleteEvalAppsAppNameEvalSetsEvalSetIdEvalCasesEvalCaseIdDeleteMutationOptions(
        options,
      );

    return useMutation(mutationOptions);
  };

/**
 * @summary Run Eval Legacy
 */
export const runEvalLegacyAppsAppNameEvalSetsEvalSetIdRunEvalPost = (
  appName: string,
  evalSetId: string,
  runEvalRequest: RunEvalRequest,
  signal?: AbortSignal,
) => {
  return customInstance<RunEvalResult[]>({
    url: `http://localhost:8000/apps/${appName}/eval_sets/${evalSetId}/run_eval`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: runEvalRequest,
    signal,
  });
};

export const getRunEvalLegacyAppsAppNameEvalSetsEvalSetIdRunEvalPostMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof runEvalLegacyAppsAppNameEvalSetsEvalSetIdRunEvalPost>
      >,
      TError,
      { appName: string; evalSetId: string; data: RunEvalRequest },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof runEvalLegacyAppsAppNameEvalSetsEvalSetIdRunEvalPost>
    >,
    TError,
    { appName: string; evalSetId: string; data: RunEvalRequest },
    TContext
  > => {
    const mutationKey = [
      "runEvalLegacyAppsAppNameEvalSetsEvalSetIdRunEvalPost",
    ];
    const { mutation: mutationOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof runEvalLegacyAppsAppNameEvalSetsEvalSetIdRunEvalPost>
      >,
      { appName: string; evalSetId: string; data: RunEvalRequest }
    > = (props) => {
      const { appName, evalSetId, data } = props ?? {};

      return runEvalLegacyAppsAppNameEvalSetsEvalSetIdRunEvalPost(
        appName,
        evalSetId,
        data,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type RunEvalLegacyAppsAppNameEvalSetsEvalSetIdRunEvalPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof runEvalLegacyAppsAppNameEvalSetsEvalSetIdRunEvalPost>
    >
  >;
export type RunEvalLegacyAppsAppNameEvalSetsEvalSetIdRunEvalPostMutationBody =
  RunEvalRequest;
export type RunEvalLegacyAppsAppNameEvalSetsEvalSetIdRunEvalPostMutationError =
  HTTPValidationError;

/**
 * @summary Run Eval Legacy
 */
export const useRunEvalLegacyAppsAppNameEvalSetsEvalSetIdRunEvalPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<
      ReturnType<typeof runEvalLegacyAppsAppNameEvalSetsEvalSetIdRunEvalPost>
    >,
    TError,
    { appName: string; evalSetId: string; data: RunEvalRequest },
    TContext
  >;
}): UseMutationResult<
  Awaited<
    ReturnType<typeof runEvalLegacyAppsAppNameEvalSetsEvalSetIdRunEvalPost>
  >,
  TError,
  { appName: string; evalSetId: string; data: RunEvalRequest },
  TContext
> => {
  const mutationOptions =
    getRunEvalLegacyAppsAppNameEvalSetsEvalSetIdRunEvalPostMutationOptions(
      options,
    );

  return useMutation(mutationOptions);
};

/**
 * Runs an eval given the details in the eval request.
 * @summary Run Eval
 */
export const runEvalAppsAppNameEvalSetsEvalSetIdRunPost = (
  appName: string,
  evalSetId: string,
  runEvalRequest: RunEvalRequest,
  signal?: AbortSignal,
) => {
  return customInstance<RunEvalResponse>({
    url: `http://localhost:8000/apps/${appName}/eval-sets/${evalSetId}/run`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: runEvalRequest,
    signal,
  });
};

export const getRunEvalAppsAppNameEvalSetsEvalSetIdRunPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runEvalAppsAppNameEvalSetsEvalSetIdRunPost>>,
    TError,
    { appName: string; evalSetId: string; data: RunEvalRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof runEvalAppsAppNameEvalSetsEvalSetIdRunPost>>,
  TError,
  { appName: string; evalSetId: string; data: RunEvalRequest },
  TContext
> => {
  const mutationKey = ["runEvalAppsAppNameEvalSetsEvalSetIdRunPost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runEvalAppsAppNameEvalSetsEvalSetIdRunPost>>,
    { appName: string; evalSetId: string; data: RunEvalRequest }
  > = (props) => {
    const { appName, evalSetId, data } = props ?? {};

    return runEvalAppsAppNameEvalSetsEvalSetIdRunPost(appName, evalSetId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RunEvalAppsAppNameEvalSetsEvalSetIdRunPostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof runEvalAppsAppNameEvalSetsEvalSetIdRunPost>>
  >;
export type RunEvalAppsAppNameEvalSetsEvalSetIdRunPostMutationBody =
  RunEvalRequest;
export type RunEvalAppsAppNameEvalSetsEvalSetIdRunPostMutationError =
  HTTPValidationError;

/**
 * @summary Run Eval
 */
export const useRunEvalAppsAppNameEvalSetsEvalSetIdRunPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runEvalAppsAppNameEvalSetsEvalSetIdRunPost>>,
    TError,
    { appName: string; evalSetId: string; data: RunEvalRequest },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof runEvalAppsAppNameEvalSetsEvalSetIdRunPost>>,
  TError,
  { appName: string; evalSetId: string; data: RunEvalRequest },
  TContext
> => {
  const mutationOptions =
    getRunEvalAppsAppNameEvalSetsEvalSetIdRunPostMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Gets the eval result for the given eval id.
 * @summary Get Eval Result
 */
export const getEvalResultAppsAppNameEvalResultsEvalResultIdGet = (
  appName: string,
  evalResultId: string,
  signal?: AbortSignal,
) => {
  return customInstance<EvalResult>({
    url: `http://localhost:8000/apps/${appName}/eval-results/${evalResultId}`,
    method: "GET",
    signal,
  });
};

export const getGetEvalResultAppsAppNameEvalResultsEvalResultIdGetQueryKey = (
  appName?: string,
  evalResultId?: string,
) => {
  return [
    `http://localhost:8000/apps/${appName}/eval-results/${evalResultId}`,
  ] as const;
};

export const getGetEvalResultAppsAppNameEvalResultsEvalResultIdGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<typeof getEvalResultAppsAppNameEvalResultsEvalResultIdGet>
    >,
    TError = HTTPValidationError,
  >(
    appName: string,
    evalResultId: string,
    options?: {
      query?: UseQueryOptions<
        Awaited<
          ReturnType<typeof getEvalResultAppsAppNameEvalResultsEvalResultIdGet>
        >,
        TError,
        TData
      >;
    },
  ) => {
    const { query: queryOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getGetEvalResultAppsAppNameEvalResultsEvalResultIdGetQueryKey(
        appName,
        evalResultId,
      );

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<typeof getEvalResultAppsAppNameEvalResultsEvalResultIdGet>
      >
    > = ({ signal }) =>
      getEvalResultAppsAppNameEvalResultsEvalResultIdGet(
        appName,
        evalResultId,
        signal,
      );

    return {
      queryKey,
      queryFn,
      enabled: !!(appName && evalResultId),
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<typeof getEvalResultAppsAppNameEvalResultsEvalResultIdGet>
      >,
      TError,
      TData
    > & { queryKey: QueryKey };
  };

export type GetEvalResultAppsAppNameEvalResultsEvalResultIdGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<typeof getEvalResultAppsAppNameEvalResultsEvalResultIdGet>
    >
  >;
export type GetEvalResultAppsAppNameEvalResultsEvalResultIdGetQueryError =
  HTTPValidationError;

/**
 * @summary Get Eval Result
 */

export function useGetEvalResultAppsAppNameEvalResultsEvalResultIdGet<
  TData = Awaited<
    ReturnType<typeof getEvalResultAppsAppNameEvalResultsEvalResultIdGet>
  >,
  TError = HTTPValidationError,
>(
  appName: string,
  evalResultId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<
        ReturnType<typeof getEvalResultAppsAppNameEvalResultsEvalResultIdGet>
      >,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions =
    getGetEvalResultAppsAppNameEvalResultsEvalResultIdGetQueryOptions(
      appName,
      evalResultId,
      options,
    );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get Eval Result Legacy
 */
export const getEvalResultLegacyAppsAppNameEvalResultsEvalResultIdGet = (
  appName: string,
  evalResultId: string,
  signal?: AbortSignal,
) => {
  return customInstance<EvalSetResult>({
    url: `http://localhost:8000/apps/${appName}/eval_results/${evalResultId}`,
    method: "GET",
    signal,
  });
};

export const getGetEvalResultLegacyAppsAppNameEvalResultsEvalResultIdGetQueryKey =
  (appName?: string, evalResultId?: string) => {
    return [
      `http://localhost:8000/apps/${appName}/eval_results/${evalResultId}`,
    ] as const;
  };

export const getGetEvalResultLegacyAppsAppNameEvalResultsEvalResultIdGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<
        typeof getEvalResultLegacyAppsAppNameEvalResultsEvalResultIdGet
      >
    >,
    TError = HTTPValidationError,
  >(
    appName: string,
    evalResultId: string,
    options?: {
      query?: UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getEvalResultLegacyAppsAppNameEvalResultsEvalResultIdGet
          >
        >,
        TError,
        TData
      >;
    },
  ) => {
    const { query: queryOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getGetEvalResultLegacyAppsAppNameEvalResultsEvalResultIdGetQueryKey(
        appName,
        evalResultId,
      );

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<
          typeof getEvalResultLegacyAppsAppNameEvalResultsEvalResultIdGet
        >
      >
    > = ({ signal }) =>
      getEvalResultLegacyAppsAppNameEvalResultsEvalResultIdGet(
        appName,
        evalResultId,
        signal,
      );

    return {
      queryKey,
      queryFn,
      enabled: !!(appName && evalResultId),
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<
          typeof getEvalResultLegacyAppsAppNameEvalResultsEvalResultIdGet
        >
      >,
      TError,
      TData
    > & { queryKey: QueryKey };
  };

export type GetEvalResultLegacyAppsAppNameEvalResultsEvalResultIdGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof getEvalResultLegacyAppsAppNameEvalResultsEvalResultIdGet
      >
    >
  >;
export type GetEvalResultLegacyAppsAppNameEvalResultsEvalResultIdGetQueryError =
  HTTPValidationError;

/**
 * @summary Get Eval Result Legacy
 */

export function useGetEvalResultLegacyAppsAppNameEvalResultsEvalResultIdGet<
  TData = Awaited<
    ReturnType<typeof getEvalResultLegacyAppsAppNameEvalResultsEvalResultIdGet>
  >,
  TError = HTTPValidationError,
>(
  appName: string,
  evalResultId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<
        ReturnType<
          typeof getEvalResultLegacyAppsAppNameEvalResultsEvalResultIdGet
        >
      >,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions =
    getGetEvalResultLegacyAppsAppNameEvalResultsEvalResultIdGetQueryOptions(
      appName,
      evalResultId,
      options,
    );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Lists all eval results for the given app.
 * @summary List Eval Results
 */
export const listEvalResultsAppsAppNameEvalResultsGet = (
  appName: string,
  signal?: AbortSignal,
) => {
  return customInstance<ListEvalResultsResponse>({
    url: `http://localhost:8000/apps/${appName}/eval-results`,
    method: "GET",
    signal,
  });
};

export const getListEvalResultsAppsAppNameEvalResultsGetQueryKey = (
  appName?: string,
) => {
  return [`http://localhost:8000/apps/${appName}/eval-results`] as const;
};

export const getListEvalResultsAppsAppNameEvalResultsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof listEvalResultsAppsAppNameEvalResultsGet>>,
  TError = HTTPValidationError,
>(
  appName: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof listEvalResultsAppsAppNameEvalResultsGet>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getListEvalResultsAppsAppNameEvalResultsGetQueryKey(appName);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listEvalResultsAppsAppNameEvalResultsGet>>
  > = ({ signal }) => listEvalResultsAppsAppNameEvalResultsGet(appName, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!appName,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof listEvalResultsAppsAppNameEvalResultsGet>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ListEvalResultsAppsAppNameEvalResultsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof listEvalResultsAppsAppNameEvalResultsGet>>
>;
export type ListEvalResultsAppsAppNameEvalResultsGetQueryError =
  HTTPValidationError;

/**
 * @summary List Eval Results
 */

export function useListEvalResultsAppsAppNameEvalResultsGet<
  TData = Awaited<ReturnType<typeof listEvalResultsAppsAppNameEvalResultsGet>>,
  TError = HTTPValidationError,
>(
  appName: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof listEvalResultsAppsAppNameEvalResultsGet>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getListEvalResultsAppsAppNameEvalResultsGetQueryOptions(
    appName,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary List Eval Results Legacy
 */
export const listEvalResultsLegacyAppsAppNameEvalResultsGet = (
  appName: string,
  signal?: AbortSignal,
) => {
  return customInstance<string[]>({
    url: `http://localhost:8000/apps/${appName}/eval_results`,
    method: "GET",
    signal,
  });
};

export const getListEvalResultsLegacyAppsAppNameEvalResultsGetQueryKey = (
  appName?: string,
) => {
  return [`http://localhost:8000/apps/${appName}/eval_results`] as const;
};

export const getListEvalResultsLegacyAppsAppNameEvalResultsGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof listEvalResultsLegacyAppsAppNameEvalResultsGet>
  >,
  TError = HTTPValidationError,
>(
  appName: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<
        ReturnType<typeof listEvalResultsLegacyAppsAppNameEvalResultsGet>
      >,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getListEvalResultsLegacyAppsAppNameEvalResultsGetQueryKey(appName);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listEvalResultsLegacyAppsAppNameEvalResultsGet>>
  > = ({ signal }) =>
    listEvalResultsLegacyAppsAppNameEvalResultsGet(appName, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!appName,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof listEvalResultsLegacyAppsAppNameEvalResultsGet>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ListEvalResultsLegacyAppsAppNameEvalResultsGetQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof listEvalResultsLegacyAppsAppNameEvalResultsGet>>
  >;
export type ListEvalResultsLegacyAppsAppNameEvalResultsGetQueryError =
  HTTPValidationError;

/**
 * @summary List Eval Results Legacy
 */

export function useListEvalResultsLegacyAppsAppNameEvalResultsGet<
  TData = Awaited<
    ReturnType<typeof listEvalResultsLegacyAppsAppNameEvalResultsGet>
  >,
  TError = HTTPValidationError,
>(
  appName: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<
        ReturnType<typeof listEvalResultsLegacyAppsAppNameEvalResultsGet>
      >,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions =
    getListEvalResultsLegacyAppsAppNameEvalResultsGetQueryOptions(
      appName,
      options,
    );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Lists all eval metrics for the given app.
 * @summary List Metrics Info
 */
export const listMetricsInfoAppsAppNameMetricsInfoGet = (
  appName: string,
  signal?: AbortSignal,
) => {
  return customInstance<ListMetricsInfoResponse>({
    url: `http://localhost:8000/apps/${appName}/metrics-info`,
    method: "GET",
    signal,
  });
};

export const getListMetricsInfoAppsAppNameMetricsInfoGetQueryKey = (
  appName?: string,
) => {
  return [`http://localhost:8000/apps/${appName}/metrics-info`] as const;
};

export const getListMetricsInfoAppsAppNameMetricsInfoGetQueryOptions = <
  TData = Awaited<ReturnType<typeof listMetricsInfoAppsAppNameMetricsInfoGet>>,
  TError = HTTPValidationError,
>(
  appName: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof listMetricsInfoAppsAppNameMetricsInfoGet>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getListMetricsInfoAppsAppNameMetricsInfoGetQueryKey(appName);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listMetricsInfoAppsAppNameMetricsInfoGet>>
  > = ({ signal }) => listMetricsInfoAppsAppNameMetricsInfoGet(appName, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!appName,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof listMetricsInfoAppsAppNameMetricsInfoGet>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ListMetricsInfoAppsAppNameMetricsInfoGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof listMetricsInfoAppsAppNameMetricsInfoGet>>
>;
export type ListMetricsInfoAppsAppNameMetricsInfoGetQueryError =
  HTTPValidationError;

/**
 * @summary List Metrics Info
 */

export function useListMetricsInfoAppsAppNameMetricsInfoGet<
  TData = Awaited<ReturnType<typeof listMetricsInfoAppsAppNameMetricsInfoGet>>,
  TError = HTTPValidationError,
>(
  appName: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof listMetricsInfoAppsAppNameMetricsInfoGet>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getListMetricsInfoAppsAppNameMetricsInfoGetQueryOptions(
    appName,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Load Artifact
 */
export const loadArtifactAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameGet =
  (
    appName: string,
    userId: string,
    sessionId: string,
    artifactName: string,
    params?: LoadArtifactAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameGetParams,
    signal?: AbortSignal,
  ) => {
    return customInstance<LoadArtifactAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameGet200>(
      {
        url: `http://localhost:8000/apps/${appName}/users/${userId}/sessions/${sessionId}/artifacts/${artifactName}`,
        method: "GET",
        params,
        signal,
      },
    );
  };

export const getLoadArtifactAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameGetQueryKey =
  (
    appName?: string,
    userId?: string,
    sessionId?: string,
    artifactName?: string,
    params?: LoadArtifactAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameGetParams,
  ) => {
    return [
      `http://localhost:8000/apps/${appName}/users/${userId}/sessions/${sessionId}/artifacts/${artifactName}`,
      ...(params ? [params] : []),
    ] as const;
  };

export const getLoadArtifactAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<
        typeof loadArtifactAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameGet
      >
    >,
    TError = HTTPValidationError,
  >(
    appName: string,
    userId: string,
    sessionId: string,
    artifactName: string,
    params?: LoadArtifactAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameGetParams,
    options?: {
      query?: UseQueryOptions<
        Awaited<
          ReturnType<
            typeof loadArtifactAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameGet
          >
        >,
        TError,
        TData
      >;
    },
  ) => {
    const { query: queryOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getLoadArtifactAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameGetQueryKey(
        appName,
        userId,
        sessionId,
        artifactName,
        params,
      );

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<
          typeof loadArtifactAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameGet
        >
      >
    > = ({ signal }) =>
      loadArtifactAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameGet(
        appName,
        userId,
        sessionId,
        artifactName,
        params,
        signal,
      );

    return {
      queryKey,
      queryFn,
      enabled: !!(appName && userId && sessionId && artifactName),
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<
          typeof loadArtifactAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameGet
        >
      >,
      TError,
      TData
    > & { queryKey: QueryKey };
  };

export type LoadArtifactAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof loadArtifactAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameGet
      >
    >
  >;
export type LoadArtifactAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameGetQueryError =
  HTTPValidationError;

/**
 * @summary Load Artifact
 */

export function useLoadArtifactAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameGet<
  TData = Awaited<
    ReturnType<
      typeof loadArtifactAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameGet
    >
  >,
  TError = HTTPValidationError,
>(
  appName: string,
  userId: string,
  sessionId: string,
  artifactName: string,
  params?: LoadArtifactAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameGetParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<
        ReturnType<
          typeof loadArtifactAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameGet
        >
      >,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions =
    getLoadArtifactAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameGetQueryOptions(
      appName,
      userId,
      sessionId,
      artifactName,
      params,
      options,
    );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Delete Artifact
 */
export const deleteArtifactAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameDelete =
  (
    appName: string,
    userId: string,
    sessionId: string,
    artifactName: string,
  ) => {
    return customInstance<null>({
      url: `http://localhost:8000/apps/${appName}/users/${userId}/sessions/${sessionId}/artifacts/${artifactName}`,
      method: "DELETE",
    });
  };

export const getDeleteArtifactAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameDeleteMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof deleteArtifactAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameDelete
        >
      >,
      TError,
      {
        appName: string;
        userId: string;
        sessionId: string;
        artifactName: string;
      },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<
        typeof deleteArtifactAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameDelete
      >
    >,
    TError,
    {
      appName: string;
      userId: string;
      sessionId: string;
      artifactName: string;
    },
    TContext
  > => {
    const mutationKey = [
      "deleteArtifactAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameDelete",
    ];
    const { mutation: mutationOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<
          typeof deleteArtifactAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameDelete
        >
      >,
      {
        appName: string;
        userId: string;
        sessionId: string;
        artifactName: string;
      }
    > = (props) => {
      const { appName, userId, sessionId, artifactName } = props ?? {};

      return deleteArtifactAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameDelete(
        appName,
        userId,
        sessionId,
        artifactName,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type DeleteArtifactAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameDeleteMutationResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof deleteArtifactAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameDelete
      >
    >
  >;

export type DeleteArtifactAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameDeleteMutationError =
  HTTPValidationError;

/**
 * @summary Delete Artifact
 */
export const useDeleteArtifactAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameDelete =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof deleteArtifactAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameDelete
        >
      >,
      TError,
      {
        appName: string;
        userId: string;
        sessionId: string;
        artifactName: string;
      },
      TContext
    >;
  }): UseMutationResult<
    Awaited<
      ReturnType<
        typeof deleteArtifactAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameDelete
      >
    >,
    TError,
    {
      appName: string;
      userId: string;
      sessionId: string;
      artifactName: string;
    },
    TContext
  > => {
    const mutationOptions =
      getDeleteArtifactAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameDeleteMutationOptions(
        options,
      );

    return useMutation(mutationOptions);
  };

/**
 * @summary Load Artifact Version
 */
export const loadArtifactVersionAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameVersionsVersionIdGet =
  (
    appName: string,
    userId: string,
    sessionId: string,
    artifactName: string,
    versionId: number,
    signal?: AbortSignal,
  ) => {
    return customInstance<LoadArtifactVersionAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameVersionsVersionIdGet200>(
      {
        url: `http://localhost:8000/apps/${appName}/users/${userId}/sessions/${sessionId}/artifacts/${artifactName}/versions/${versionId}`,
        method: "GET",
        signal,
      },
    );
  };

export const getLoadArtifactVersionAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameVersionsVersionIdGetQueryKey =
  (
    appName?: string,
    userId?: string,
    sessionId?: string,
    artifactName?: string,
    versionId?: number,
  ) => {
    return [
      `http://localhost:8000/apps/${appName}/users/${userId}/sessions/${sessionId}/artifacts/${artifactName}/versions/${versionId}`,
    ] as const;
  };

export const getLoadArtifactVersionAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameVersionsVersionIdGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<
        typeof loadArtifactVersionAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameVersionsVersionIdGet
      >
    >,
    TError = HTTPValidationError,
  >(
    appName: string,
    userId: string,
    sessionId: string,
    artifactName: string,
    versionId: number,
    options?: {
      query?: UseQueryOptions<
        Awaited<
          ReturnType<
            typeof loadArtifactVersionAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameVersionsVersionIdGet
          >
        >,
        TError,
        TData
      >;
    },
  ) => {
    const { query: queryOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getLoadArtifactVersionAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameVersionsVersionIdGetQueryKey(
        appName,
        userId,
        sessionId,
        artifactName,
        versionId,
      );

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<
          typeof loadArtifactVersionAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameVersionsVersionIdGet
        >
      >
    > = ({ signal }) =>
      loadArtifactVersionAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameVersionsVersionIdGet(
        appName,
        userId,
        sessionId,
        artifactName,
        versionId,
        signal,
      );

    return {
      queryKey,
      queryFn,
      enabled: !!(appName && userId && sessionId && artifactName && versionId),
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<
          typeof loadArtifactVersionAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameVersionsVersionIdGet
        >
      >,
      TError,
      TData
    > & { queryKey: QueryKey };
  };

export type LoadArtifactVersionAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameVersionsVersionIdGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof loadArtifactVersionAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameVersionsVersionIdGet
      >
    >
  >;
export type LoadArtifactVersionAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameVersionsVersionIdGetQueryError =
  HTTPValidationError;

/**
 * @summary Load Artifact Version
 */

export function useLoadArtifactVersionAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameVersionsVersionIdGet<
  TData = Awaited<
    ReturnType<
      typeof loadArtifactVersionAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameVersionsVersionIdGet
    >
  >,
  TError = HTTPValidationError,
>(
  appName: string,
  userId: string,
  sessionId: string,
  artifactName: string,
  versionId: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<
        ReturnType<
          typeof loadArtifactVersionAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameVersionsVersionIdGet
        >
      >,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions =
    getLoadArtifactVersionAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameVersionsVersionIdGetQueryOptions(
      appName,
      userId,
      sessionId,
      artifactName,
      versionId,
      options,
    );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary List Artifact Names
 */
export const listArtifactNamesAppsAppNameUsersUserIdSessionsSessionIdArtifactsGet =
  (
    appName: string,
    userId: string,
    sessionId: string,
    signal?: AbortSignal,
  ) => {
    return customInstance<string[]>({
      url: `http://localhost:8000/apps/${appName}/users/${userId}/sessions/${sessionId}/artifacts`,
      method: "GET",
      signal,
    });
  };

export const getListArtifactNamesAppsAppNameUsersUserIdSessionsSessionIdArtifactsGetQueryKey =
  (appName?: string, userId?: string, sessionId?: string) => {
    return [
      `http://localhost:8000/apps/${appName}/users/${userId}/sessions/${sessionId}/artifacts`,
    ] as const;
  };

export const getListArtifactNamesAppsAppNameUsersUserIdSessionsSessionIdArtifactsGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<
        typeof listArtifactNamesAppsAppNameUsersUserIdSessionsSessionIdArtifactsGet
      >
    >,
    TError = HTTPValidationError,
  >(
    appName: string,
    userId: string,
    sessionId: string,
    options?: {
      query?: UseQueryOptions<
        Awaited<
          ReturnType<
            typeof listArtifactNamesAppsAppNameUsersUserIdSessionsSessionIdArtifactsGet
          >
        >,
        TError,
        TData
      >;
    },
  ) => {
    const { query: queryOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getListArtifactNamesAppsAppNameUsersUserIdSessionsSessionIdArtifactsGetQueryKey(
        appName,
        userId,
        sessionId,
      );

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<
          typeof listArtifactNamesAppsAppNameUsersUserIdSessionsSessionIdArtifactsGet
        >
      >
    > = ({ signal }) =>
      listArtifactNamesAppsAppNameUsersUserIdSessionsSessionIdArtifactsGet(
        appName,
        userId,
        sessionId,
        signal,
      );

    return {
      queryKey,
      queryFn,
      enabled: !!(appName && userId && sessionId),
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<
          typeof listArtifactNamesAppsAppNameUsersUserIdSessionsSessionIdArtifactsGet
        >
      >,
      TError,
      TData
    > & { queryKey: QueryKey };
  };

export type ListArtifactNamesAppsAppNameUsersUserIdSessionsSessionIdArtifactsGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof listArtifactNamesAppsAppNameUsersUserIdSessionsSessionIdArtifactsGet
      >
    >
  >;
export type ListArtifactNamesAppsAppNameUsersUserIdSessionsSessionIdArtifactsGetQueryError =
  HTTPValidationError;

/**
 * @summary List Artifact Names
 */

export function useListArtifactNamesAppsAppNameUsersUserIdSessionsSessionIdArtifactsGet<
  TData = Awaited<
    ReturnType<
      typeof listArtifactNamesAppsAppNameUsersUserIdSessionsSessionIdArtifactsGet
    >
  >,
  TError = HTTPValidationError,
>(
  appName: string,
  userId: string,
  sessionId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<
        ReturnType<
          typeof listArtifactNamesAppsAppNameUsersUserIdSessionsSessionIdArtifactsGet
        >
      >,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions =
    getListArtifactNamesAppsAppNameUsersUserIdSessionsSessionIdArtifactsGetQueryOptions(
      appName,
      userId,
      sessionId,
      options,
    );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary List Artifact Versions
 */
export const listArtifactVersionsAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameVersionsGet =
  (
    appName: string,
    userId: string,
    sessionId: string,
    artifactName: string,
    signal?: AbortSignal,
  ) => {
    return customInstance<number[]>({
      url: `http://localhost:8000/apps/${appName}/users/${userId}/sessions/${sessionId}/artifacts/${artifactName}/versions`,
      method: "GET",
      signal,
    });
  };

export const getListArtifactVersionsAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameVersionsGetQueryKey =
  (
    appName?: string,
    userId?: string,
    sessionId?: string,
    artifactName?: string,
  ) => {
    return [
      `http://localhost:8000/apps/${appName}/users/${userId}/sessions/${sessionId}/artifacts/${artifactName}/versions`,
    ] as const;
  };

export const getListArtifactVersionsAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameVersionsGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<
        typeof listArtifactVersionsAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameVersionsGet
      >
    >,
    TError = HTTPValidationError,
  >(
    appName: string,
    userId: string,
    sessionId: string,
    artifactName: string,
    options?: {
      query?: UseQueryOptions<
        Awaited<
          ReturnType<
            typeof listArtifactVersionsAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameVersionsGet
          >
        >,
        TError,
        TData
      >;
    },
  ) => {
    const { query: queryOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getListArtifactVersionsAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameVersionsGetQueryKey(
        appName,
        userId,
        sessionId,
        artifactName,
      );

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<
          typeof listArtifactVersionsAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameVersionsGet
        >
      >
    > = ({ signal }) =>
      listArtifactVersionsAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameVersionsGet(
        appName,
        userId,
        sessionId,
        artifactName,
        signal,
      );

    return {
      queryKey,
      queryFn,
      enabled: !!(appName && userId && sessionId && artifactName),
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<
          typeof listArtifactVersionsAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameVersionsGet
        >
      >,
      TError,
      TData
    > & { queryKey: QueryKey };
  };

export type ListArtifactVersionsAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameVersionsGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof listArtifactVersionsAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameVersionsGet
      >
    >
  >;
export type ListArtifactVersionsAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameVersionsGetQueryError =
  HTTPValidationError;

/**
 * @summary List Artifact Versions
 */

export function useListArtifactVersionsAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameVersionsGet<
  TData = Awaited<
    ReturnType<
      typeof listArtifactVersionsAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameVersionsGet
    >
  >,
  TError = HTTPValidationError,
>(
  appName: string,
  userId: string,
  sessionId: string,
  artifactName: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<
        ReturnType<
          typeof listArtifactVersionsAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameVersionsGet
        >
      >,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions =
    getListArtifactVersionsAppsAppNameUsersUserIdSessionsSessionIdArtifactsArtifactNameVersionsGetQueryOptions(
      appName,
      userId,
      sessionId,
      artifactName,
      options,
    );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Run Agent
 */
export const runAgentRunPost = (
  runAgentRequest: RunAgentRequest,
  signal?: AbortSignal,
) => {
  return customInstance<EventOutput[]>({
    url: `http://localhost:8000/run`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: runAgentRequest,
    signal,
  });
};

export const getRunAgentRunPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runAgentRunPost>>,
    TError,
    { data: RunAgentRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof runAgentRunPost>>,
  TError,
  { data: RunAgentRequest },
  TContext
> => {
  const mutationKey = ["runAgentRunPost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runAgentRunPost>>,
    { data: RunAgentRequest }
  > = (props) => {
    const { data } = props ?? {};

    return runAgentRunPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RunAgentRunPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof runAgentRunPost>>
>;
export type RunAgentRunPostMutationBody = RunAgentRequest;
export type RunAgentRunPostMutationError = HTTPValidationError;

/**
 * @summary Run Agent
 */
export const useRunAgentRunPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runAgentRunPost>>,
    TError,
    { data: RunAgentRequest },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof runAgentRunPost>>,
  TError,
  { data: RunAgentRequest },
  TContext
> => {
  const mutationOptions = getRunAgentRunPostMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Run Agent Sse
 */
export const runAgentSseRunSsePost = (
  runAgentRequest: RunAgentRequest,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>({
    url: `http://localhost:8000/run_sse`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: runAgentRequest,
    signal,
  });
};

export const getRunAgentSseRunSsePostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runAgentSseRunSsePost>>,
    TError,
    { data: RunAgentRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof runAgentSseRunSsePost>>,
  TError,
  { data: RunAgentRequest },
  TContext
> => {
  const mutationKey = ["runAgentSseRunSsePost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runAgentSseRunSsePost>>,
    { data: RunAgentRequest }
  > = (props) => {
    const { data } = props ?? {};

    return runAgentSseRunSsePost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RunAgentSseRunSsePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof runAgentSseRunSsePost>>
>;
export type RunAgentSseRunSsePostMutationBody = RunAgentRequest;
export type RunAgentSseRunSsePostMutationError = HTTPValidationError;

/**
 * @summary Run Agent Sse
 */
export const useRunAgentSseRunSsePost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runAgentSseRunSsePost>>,
    TError,
    { data: RunAgentRequest },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof runAgentSseRunSsePost>>,
  TError,
  { data: RunAgentRequest },
  TContext
> => {
  const mutationOptions = getRunAgentSseRunSsePostMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get Event Graph
 */
export const getEventGraphAppsAppNameUsersUserIdSessionsSessionIdEventsEventIdGraphGet =
  (
    appName: string,
    userId: string,
    sessionId: string,
    eventId: string,
    signal?: AbortSignal,
  ) => {
    return customInstance<unknown>({
      url: `http://localhost:8000/apps/${appName}/users/${userId}/sessions/${sessionId}/events/${eventId}/graph`,
      method: "GET",
      signal,
    });
  };

export const getGetEventGraphAppsAppNameUsersUserIdSessionsSessionIdEventsEventIdGraphGetQueryKey =
  (appName?: string, userId?: string, sessionId?: string, eventId?: string) => {
    return [
      `http://localhost:8000/apps/${appName}/users/${userId}/sessions/${sessionId}/events/${eventId}/graph`,
    ] as const;
  };

export const getGetEventGraphAppsAppNameUsersUserIdSessionsSessionIdEventsEventIdGraphGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<
        typeof getEventGraphAppsAppNameUsersUserIdSessionsSessionIdEventsEventIdGraphGet
      >
    >,
    TError = HTTPValidationError,
  >(
    appName: string,
    userId: string,
    sessionId: string,
    eventId: string,
    options?: {
      query?: UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getEventGraphAppsAppNameUsersUserIdSessionsSessionIdEventsEventIdGraphGet
          >
        >,
        TError,
        TData
      >;
    },
  ) => {
    const { query: queryOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getGetEventGraphAppsAppNameUsersUserIdSessionsSessionIdEventsEventIdGraphGetQueryKey(
        appName,
        userId,
        sessionId,
        eventId,
      );

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<
          typeof getEventGraphAppsAppNameUsersUserIdSessionsSessionIdEventsEventIdGraphGet
        >
      >
    > = ({ signal }) =>
      getEventGraphAppsAppNameUsersUserIdSessionsSessionIdEventsEventIdGraphGet(
        appName,
        userId,
        sessionId,
        eventId,
        signal,
      );

    return {
      queryKey,
      queryFn,
      enabled: !!(appName && userId && sessionId && eventId),
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<
          typeof getEventGraphAppsAppNameUsersUserIdSessionsSessionIdEventsEventIdGraphGet
        >
      >,
      TError,
      TData
    > & { queryKey: QueryKey };
  };

export type GetEventGraphAppsAppNameUsersUserIdSessionsSessionIdEventsEventIdGraphGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof getEventGraphAppsAppNameUsersUserIdSessionsSessionIdEventsEventIdGraphGet
      >
    >
  >;
export type GetEventGraphAppsAppNameUsersUserIdSessionsSessionIdEventsEventIdGraphGetQueryError =
  HTTPValidationError;

/**
 * @summary Get Event Graph
 */

export function useGetEventGraphAppsAppNameUsersUserIdSessionsSessionIdEventsEventIdGraphGet<
  TData = Awaited<
    ReturnType<
      typeof getEventGraphAppsAppNameUsersUserIdSessionsSessionIdEventsEventIdGraphGet
    >
  >,
  TError = HTTPValidationError,
>(
  appName: string,
  userId: string,
  sessionId: string,
  eventId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<
        ReturnType<
          typeof getEventGraphAppsAppNameUsersUserIdSessionsSessionIdEventsEventIdGraphGet
        >
      >,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions =
    getGetEventGraphAppsAppNameUsersUserIdSessionsSessionIdEventsEventIdGraphGetQueryOptions(
      appName,
      userId,
      sessionId,
      eventId,
      options,
    );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Health check endpoint
 * @summary Health Check
 */
export const healthCheckHealthGet = (signal?: AbortSignal) => {
  return customInstance<unknown>({
    url: `http://localhost:8000/health`,
    method: "GET",
    signal,
  });
};

export const getHealthCheckHealthGetQueryKey = () => {
  return [`http://localhost:8000/health`] as const;
};

export const getHealthCheckHealthGetQueryOptions = <
  TData = Awaited<ReturnType<typeof healthCheckHealthGet>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof healthCheckHealthGet>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getHealthCheckHealthGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof healthCheckHealthGet>>
  > = ({ signal }) => healthCheckHealthGet(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof healthCheckHealthGet>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type HealthCheckHealthGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthCheckHealthGet>>
>;
export type HealthCheckHealthGetQueryError = unknown;

/**
 * @summary Health Check
 */

export function useHealthCheckHealthGet<
  TData = Awaited<ReturnType<typeof healthCheckHealthGet>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof healthCheckHealthGet>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getHealthCheckHealthGetQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get information about the service
 * @summary Get Info
 */
export const getInfoInfoGet = (signal?: AbortSignal) => {
  return customInstance<unknown>({
    url: `http://localhost:8000/info`,
    method: "GET",
    signal,
  });
};

export const getGetInfoInfoGetQueryKey = () => {
  return [`http://localhost:8000/info`] as const;
};

export const getGetInfoInfoGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getInfoInfoGet>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getInfoInfoGet>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetInfoInfoGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInfoInfoGet>>> = ({
    signal,
  }) => getInfoInfoGet(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getInfoInfoGet>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetInfoInfoGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInfoInfoGet>>
>;
export type GetInfoInfoGetQueryError = unknown;

/**
 * @summary Get Info
 */

export function useGetInfoInfoGet<
  TData = Awaited<ReturnType<typeof getInfoInfoGet>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getInfoInfoGet>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetInfoInfoGetQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
